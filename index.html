<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>전염병 확산 게임 - v3.0 (SVG 169타일 · 말 시각화)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg: #f5f5f7;
      --panel-bg: #ffffff;
      --border: #d0d0dd;
      --accent: #4a6fff;
      --text-main: #222222;
      --text-muted: #666666;
      --radius-lg: 16px;
      --shadow-soft: 0 10px 30px rgba(0, 0, 0, 0.05);
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      background: var(--bg);
      color: var(--text-main);
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: stretch;
    }
    .app {
      width: 100%;
      max-width: 1400px;
      min-height: 100vh;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    header {
      background: var(--panel-bg);
      border-radius: var(--radius-lg);
      padding: 12px 16px;
      box-shadow: var(--shadow-soft);
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }
    header h1 {
      font-size: 1.1rem;
      font-weight: 700;
    }
    .header-right {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      font-size: 0.85rem;
      color: var(--text-muted);
    }
    .badge {
      padding: 4px 8px;
      border-radius: 999px;
      background: #eef0ff;
      color: var(--accent);
      font-weight: 600;
      font-size: 0.75rem;
    }
    .btn {
      border: none;
      border-radius: 999px;
      padding: 6px 12px;
      font-size: 0.8rem;
      cursor: pointer;
      background: var(--accent);
      color: #fff;
      font-weight: 600;
      transition: transform 0.08s ease;
      box-shadow: 0 4px 12px rgba(74, 111, 255, 0.35);
    }
    .btn.secondary {
      background: #ececf5;
      color: var(--text-main);
      box-shadow: none;
    }
    .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(74, 111, 255, 0.5);
    }
    main.layout {
      flex: 1;
      display: grid;
      grid-template-columns: minmax(0, 2.8fr) minmax(0, 1.2fr);
      gap: 12px;
      min-height: 0;
    }
    .map-panel {
      background: var(--panel-bg);
      border-radius: var(--radius-lg);
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      box-shadow: var(--shadow-soft);
    }
    .panel-header {
      display: flex;
      justify-content: space-between;
      font-size: 0.85rem;
    }
    .panel-header span:last-child {
      color: var(--text-muted);
    }

    /* ===== SVG 맵 컨테이너 ===== */
    .svg-map {
      position: relative;
      flex: 1;
      overflow: auto;
      background: #f9fafb;
      border-radius: 10px;
    }
    .svg-map svg {
      width: 100%;
      height: auto;
      display: block;
    }

    /* SVG 위에 덮는 오버레이 (말/텍스트) */
    #overlayLayer {
      position: absolute;
      inset: 0;
      pointer-events: none; /* 기본은 투명 레이어 */
    }

    .tile-overlay {
      position: absolute;
      transform: translate(-50%, -50%);
      font-size: 0.55rem;
      border-radius: 4px;
      padding: 2px 3px;
      border: none;
      pointer-events: auto; /* 이 박스는 클릭 허용 */
    }
    .tile-overlay.selected {
      box-shadow: 0 0 0 2px rgba(74, 111, 255, 0.7);
      border-color: var(--accent);
    }
    .tile-top {
      font-weight: 600;
      margin-bottom: 1px;
      display: flex;
      justify-content: space-between;
      gap: 4px;
    }
    .tile-bottom {
      display: flex;
      flex-direction: column;
      gap: 1px;
    }
    .tile-bottom span.label {
      color: var(--text-muted);
    }

    .tile-pieces {
      margin-top: 1px;
      display: flex;
      flex-wrap: wrap;
      gap: 2px;
    }
    .piece {
      width: 20px;
      height: 20px;
      box-sizing: border-box;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      border: none;
    }
    .piece.player {
      background-image: url("./assets/player-normal.svg");
    }
    .piece.infected {
      background-image: url("./assets/player-infected.svg");
    }
    .piece.vaccinated {
      background-image: url("./assets/player-vaccinated.svg");
    }
    .piece.me {
      box-shadow: 0 0 0 2px #ff9800; /* 주황색 테두리 */
      border-radius: 50%;
    }

    .side-panel {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .card {
      background: var(--panel-bg);
      border-radius: var(--radius-lg);
      padding: 10px 12px;
      box-shadow: var(--shadow-soft);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }
    .stat-item {
      border: 1px solid #ececf5;
      border-radius: 10px;
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 2px;
      font-size: 0.8rem;
    }
    .stat-label {
      color: var(--text-muted);
      font-size: 0.75rem;
    }
    .stat-value {
      font-weight: 700;
      font-size: 0.95rem;
    }
    .stat-note {
      font-size: 0.7rem;
      color: var(--text-muted);
    }
    .stat-history {
      margin-top: 6px;
      padding-top: 6px;
      border-top: 1px dashed #ccc;
      font-size: 0.75rem;
      max-height: 120px;
      overflow-y: auto;
    }
    .log-list {
      list-style: none;
      max-height: 160px;
      overflow-y: auto;
      font-size: 0.8rem;
    }
    footer {
      font-size: 0.75rem;
      color: var(--text-muted);
      padding: 4px;
    }
    .toggle-label {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 0.78rem;
    }
  </style>
</head>

<body>
  <div class="app">
    <header>
      <h1>전염병 확산 게임 — 싱글플레이 프로토타입 v3.0</h1>
      <div class="header-right">
        <span class="badge">GitHub + Netlify 배포</span>
        <span>플레이어 25명 · 시민 30만명 · 타일 169개</span>
        <button class="btn secondary" id="addDummyLogBtn">테스트 로그 추가</button>
        <button class="btn secondary" id="newGameBtn">새 게임</button>
        <button class="btn" id="nextTurnBtn">다음 턴 진행</button>
      </div>
    </header>

    <main class="layout">
      <section class="map-panel">
        <div class="panel-header">
          <span>맵 (SVG 169 타일)</span>
          <span>정육각형 SVG 맵 · 6방향 이동</span>
        </div>

        <div class="svg-map" id="svgMapContainer">
          <!-- JS에서 map.svg 삽입 -->
          <div id="overlayLayer"></div>
        </div>
      </section>

      <section class="side-panel">
        <div class="card">
          <div class="stats-grid">
            <div class="stat-item">
              <div class="stat-label">전체 인구</div>
              <div class="stat-value" id="statTotal">525</div>
              <div class="stat-note">플레이어 25 + 시민 300000</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">감염 인구</div>
              <div class="stat-value" id="statInfected">0</div>
              <div class="stat-note">플레이어 + 시민 합산</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">감염률</div>
              <div class="stat-value" id="statRatio">0%</div>
              <div class="stat-note">전체 대비 비율</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">현재 턴</div>
              <div class="stat-value" id="statTurn">1</div>
              <div class="stat-note">턴 제한 없음</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">열린 상자 수</div>
              <div class="stat-value" id="statOpenedChests">0 / 8</div>
              <div class="stat-note">8개 열면 백신 완성</div>
            </div>
            <div class="stat-item">
              <div class="stat-label">백신 상태</div>
              <div class="stat-value" id="statVaccineStatus">개발 전</div>
              <div class="stat-note">
                <label class="toggle-label">
                  <input type="checkbox" id="vaccineToggle" checked />
                  백신 시스템 사용
                </label>
              </div>
            </div>
          </div>

          <div class="stat-history" id="infectedHistoryBox">
            <div><b>턴별 누적 감염 인구 (기록용)</b></div>
            <div>아직 데이터가 없습니다.</div>
          </div>

          <div class="stat-history" id="newInfectedHistoryBox">
            <div><b>턴별 신규 감염자 수 (기록용)</b></div>
            <div>아직 데이터가 없습니다.</div>
          </div>

          <div id="selectedPlayerInfo" style="margin-top:6px; font-size:0.78rem;">
            선택된 플레이어: 없음 (타일을 클릭해서 플레이어 선택/이동)
          </div>
        </div>

        <div class="card">
          <div style="font-weight:600">턴 로그</div>
          <ul class="log-list" id="logList"></ul>
        </div>
      </section>
    </main>

    <footer>
      ※ 이 버전은 SVG 맵(169타일) 위에서 플레이어/시민을 시각화하고, 감염 확산 패턴을 관찰하기 위한 프로토타입입니다.
    </footer>
  </div>


  <script src="https://www.gstatic.com/firebasejs/10.13.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.13.2/firebase-database-compat.js"></script>
  

  <script>
    // =========================
    // 0. Firebase 초기화 (Realtime DB)
    // =========================
    const firebaseConfig = {
      apiKey: "AIzaSyD78qp_t_LZnXEnPHnKoaXB9RYLIsu82K4",
      authDomain: "infectiongametest.firebaseapp.com",
      databaseURL: "https://infectiongametest-default-rtdb.firebaseio.com",
      projectId: "infectiongametest",
      storageBucket: "infectiongametest.firebasestorage.app",
      messagingSenderId: "1098044286154",
      appId: "1:1098044286154:web:69cb7e1512172a974d0033",
      measurementId: "G-G2TLQCTXSJ"
    };

    firebase.initializeApp(firebaseConfig);
    const rtdb = firebase.database();
      
    // =========================
    // 1. 설정 (Config)
    // =========================
    const GameConfig = {
      NUM_TILES: 169,         // SVG 타일 개수에 맞춤 (0~168)
      NUM_CITIZENS: 300000,      // 필요하면 여기서 시민 수 조절
      NUM_PLAYERS: 25,
      BASE_INFECTION_RATE: 0.8,   // 시민 감염 기본 80%
      PLAYER_BASE_RATE: 1.0,      // 감염된 플레이어 → 시민 감염 시도 확률
      VACCINE_REDUCTION_FACTOR: 0.05, // 백신 후 감염률 95% 감소
      CHESTS_REQUIRED_FOR_VACCINE: 5,
      RECOVERY_TURNS: 4
    };

    // =========================
    // 2. 상태 (State)
    // =========================
    const GameState = {
      currentTurn: 1,
      entities: [],

      historyCumulativeInfected: [],
      historyNewInfected: [],
      lastRecordedTurn: 0,
      cumulativeInfectedTotal: 0,
      activeChestTiles: new Set(),
      chestWave: 0,
      openedChestCount: 0,
      vaccineActive: false,
      vaccineFeatureEnabled: true,

      selectedPlayer: null,
      selectedPlayerTileIndex: null,
      playersMovedThisTurn: new Set(),

      tileElements: [],      // [index] -> { path, overlay, pop, inf, ply, pieces }
      tileCenters: [],       // [index] -> { x, y }
      neighborMap: [],        // [index] -> [neighborIndex ...]

      // ★ 서버(교사)에서 받은 요약값 저장용
      remoteInfectedTotal: null,
      remoteTileStats: null
    };

    // =========================
    // 네트워크/멀티플레이 상태
    // =========================
    const NetState = {
      roomId: null,
      isTeacher: false,      // 교사(방장)인지
      playerId: null,        // 이 브라우저에 할당된 player 엔티티 id (예: "P3")
      nickname: null,

      roomRef: null,
      playersRef: null,
      movesRef: null,
      stateRef: null
    };

    // =========================
    // 3. UI 요소 참조 (DOM)
    // =========================
    const UI = {
      svgMapContainer: document.getElementById("svgMapContainer"),
      overlayLayer: document.getElementById("overlayLayer"),
      hexGrid: null, // 더 이상 사용 X (구 헥사맵 삭제)

      logList: document.getElementById("logList"),
      statTurn: document.getElementById("statTurn"),
      statInfected: document.getElementById("statInfected"),
      statRatio: document.getElementById("statRatio"),
      statTotal: document.getElementById("statTotal"),
      statOpenedChests: document.getElementById("statOpenedChests"),
      statVaccineStatus: document.getElementById("statVaccineStatus"),
      infectedHistoryBox: document.getElementById("infectedHistoryBox"),
      newInfectedHistoryBox: document.getElementById("newInfectedHistoryBox"),
      vaccineToggle: document.getElementById("vaccineToggle"),
      selectedPlayerInfo: document.getElementById("selectedPlayerInfo"),
      addDummyLogBtn: document.getElementById("addDummyLogBtn"),
      nextTurnBtn: document.getElementById("nextTurnBtn"),
      newGameBtn: document.getElementById("newGameBtn")
    };

    UI.statTotal.textContent =
      GameConfig.NUM_CITIZENS + GameConfig.NUM_PLAYERS;

    // =========================
    // 4. 유틸 함수
    // =========================
    const randInt = max => Math.floor(Math.random() * max);

    function addLog(msg) {
      const li = document.createElement("li");
      li.textContent = `T${GameState.currentTurn} ${msg}`;
      UI.logList.appendChild(li);
      UI.logList.scrollTop = UI.logList.scrollHeight;
    }

    function addInitialLog() {
      const li = document.createElement("li");
      li.textContent =
        "T0 게임이 초기화되었습니다. 감염자 1명이 무작위 지정됨.";
      UI.logList.appendChild(li);
    }

    function computeInfectedCount() {
      return GameState.entities.filter(e => e.infected).length;
    }

    // =========================
    // 5. SVG 맵 로드 및 타일/이웃 설정
    // =========================
    function loadSVGMap() {
      // Netlify 기준: ./assets/map.svg
      return fetch("./assets/map.svg")
        .then(res => res.text())
        .then(svgText => {
          UI.svgMapContainer.insertAdjacentHTML("afterbegin", svgText);
          const svgElement = UI.svgMapContainer.querySelector("svg");
          if (!svgElement) {
            console.error("SVG를 찾을 수 없습니다.");
            return;
          }

          const paths = svgElement.querySelectorAll("path[data-tile-index]");
          const numTiles = paths.length;
          console.log("SVG 타일 개수:", numTiles);

          if (numTiles !== GameConfig.NUM_TILES) {
            console.warn(
              "GameConfig.NUM_TILES와 SVG 타일 수가 다릅니다. SVG 기준으로 맞춥니다."
            );
            GameConfig.NUM_TILES = numTiles;
          }

          // viewBox 기준 좌표 → 퍼센트로 변환하기 위해 viewBox 정보 사용
          let vb = svgElement.getAttribute("viewBox");
          let viewW = 2300, viewH = 2006;
          if (vb) {
            const parts = vb.split(/\s+/).map(Number);
            if (parts.length === 4) {
              viewW = parts[2];
              viewH = parts[3];
            }
          }

          // 각 타일의 중심 좌표 계산
          GameState.tileCenters = new Array(GameConfig.NUM_TILES);
          paths.forEach(p => {
            const idx = parseInt(p.getAttribute("data-tile-index"), 10);
            const box = p.getBBox();
            const cx = box.x + box.width / 2;
            const cy = box.y + box.height / 2;
            GameState.tileCenters[idx] = { x: cx, y: cy };
          });

          // 오버레이 타일 생성 (말/숫자 표시)
          GameState.tileElements = new Array(GameConfig.NUM_TILES);
          for (let i = 0; i < GameConfig.NUM_TILES; i++) {
            const path = svgElement.querySelector(`path[data-tile-index="${i}"]`);
            if (!path) continue;

            const center = GameState.tileCenters[i];
            const leftPercent = (center.x / viewW) * 100;
            const topPercent = (center.y / viewH) * 100;

            const overlay = document.createElement("div");
            overlay.className = "tile-overlay";
            overlay.style.left = leftPercent + "%";
            overlay.style.top = topPercent + "%";
            overlay.dataset.tileIndex = i;

            overlay.innerHTML = `
              <div class="tile-bottom">
                <div><span class="label">인구:</span> <span class="pop">0</span></div>
                <div class="tile-pieces"></div>
              </div>
            `;

            // 클릭하면 해당 타일 선택 / 이동
            overlay.addEventListener("click", (e) => {
              e.stopPropagation();
              onTileClick(i);
            });
            path.addEventListener("click", (e) => {
              e.stopPropagation();
              onTileClick(i);
            });

            UI.overlayLayer.appendChild(overlay);

            GameState.tileElements[i] = {
              path,
              overlay,
              pop: overlay.querySelector(".pop"),
              pieces: overlay.querySelector(".tile-pieces")
            };
          }

          // 이웃(6방향) 계산
          buildNeighborMap();
          console.log("SVG 기반 이웃 관계 설정 완료");
        })
        .catch(err => console.error("SVG 로드 오류:", err));
    }

    function buildNeighborMap() {
      const N = GameConfig.NUM_TILES;
      const centers = GameState.tileCenters;
      GameState.neighborMap = new Array(N);

      for (let i = 0; i < N; i++) {
        const ci = centers[i];
        if (!ci) continue;

        const dists = [];
        for (let j = 0; j < N; j++) {
          if (i === j) continue;
          const cj = centers[j];
          if (!cj) continue;
          const dx = cj.x - ci.x;
          const dy = cj.y - ci.y;
          const dist2 = dx * dx + dy * dy;
          dists.push({ j, dist2 });
        }

        dists.sort((a, b) => a.dist2 - b.dist2);
        if (dists.length === 0) {
          GameState.neighborMap[i] = [];
          continue;
        }

        const baseDist2 = dists[0].dist2;
        const threshold = baseDist2 * 2.25; // (1.5)^2 정도

        const neighbors = [];
        for (const d of dists) {
          if (d.dist2 <= threshold && neighbors.length < 6) {
            neighbors.push(d.j);
          }
        }
        GameState.neighborMap[i] = neighbors;
      }
    }

    function getNeighborIndices(i) {
      return GameState.neighborMap[i] || [];
    }
    //백신패치중추가한부분
    function areAllPlayersVaccinated() {
      const players = GameState.entities.filter(e => e.type === "player");
      if (players.length === 0) return false;
      return players.every(p => p.vaccinated);
    }

    function spreadVaccineFromPlayers() {
      const state = GameState;

      const vaccinatedTiles = new Set();
      for (const e of state.entities) {
        if (e.type === "player" && e.vaccinated) {
          vaccinatedTiles.add(e.tileIndex);

          const neighbors = getNeighborIndices(e.tileIndex);
          for (const n of neighbors) {
            vaccinatedTiles.add(n);
          }
        }
      }
      if (vaccinatedTiles.size === 0) return;
      for (const e of state.entities) {
        if (e.type !== "citizen") continue;
        if (vaccinatedTiles.has(e.tileIndex)) {
          e.vaccinated = true;
        }
      }
    }

    // =========================
    // 6. 엔티티 초기화
    // =========================
    function initEntities() {
      const { NUM_CITIZENS, NUM_PLAYERS, NUM_TILES } = GameConfig;
      const ents = [];
      for (let i = 0; i < NUM_CITIZENS; i++) {
        ents.push({
          id: "C" + i,
          type: "citizen",
          tileIndex: randInt(NUM_TILES),
          infected: false,
          infectedTurn: null, 
          recovered: false,
          vaccinated: false
        });
      }
      for (let i = 0; i < NUM_PLAYERS; i++) {
        ents.push({
          id: "P" + i,
          type: "player",
          tileIndex: randInt(NUM_TILES),
          infected: false,
          vaccinated: false
        });
      }
      const randP = NUM_CITIZENS + randInt(NUM_PLAYERS);
      ents[randP].infected = true;

      GameState.entities = ents;
    }

    // =========================
    // 7. 플레이어 선택/이동
    // =========================
    function updateSelectedPlayerInfo() {
      const { selectedPlayer, playersMovedThisTurn } = GameState;
      if (!selectedPlayer) {
        UI.selectedPlayerInfo.textContent =
          "선택된 플레이어: 없음 (타일을 클릭해서 플레이어 선택)";
        return;
      }
      const movedFlag = playersMovedThisTurn.has(selectedPlayer.id)
        ? " / 이 턴 이동 완료"
        : " / 이 턴 이동 가능";
      UI.selectedPlayerInfo.textContent =
        `선택된 플레이어: ${selectedPlayer.id} (현재 타일 #${selectedPlayer.tileIndex})${movedFlag}`;
    }

    function clearSelection() {
      if (GameState.selectedPlayerTileIndex !== null) {
        const el = GameState.tileElements[GameState.selectedPlayerTileIndex];
        if (el && el.overlay) {
          el.overlay.classList.remove("selected");
        }
      }
      GameState.selectedPlayer = null;
      GameState.selectedPlayerTileIndex = null;
      updateSelectedPlayerInfo();
    }

    function selectPlayerOnTile(tileIndex) {
      const player = GameState.entities.find(
        e => e.type === "player" && e.tileIndex === tileIndex
      );
      if (!player) {
        clearSelection();
        return;
      }
      if (GameState.selectedPlayerTileIndex !== null) {
        const prevEl = GameState.tileElements[GameState.selectedPlayerTileIndex];
        if (prevEl && prevEl.overlay) {
          prevEl.overlay.classList.remove("selected");
        }
      }
      GameState.selectedPlayer = player;
      GameState.selectedPlayerTileIndex = tileIndex;
      const newEl = GameState.tileElements[tileIndex];
      if (newEl && newEl.overlay) {
        newEl.overlay.classList.add("selected");
      }
      updateSelectedPlayerInfo();
    }

    function onTileClick(tileIndex) {
      const state = GameState;

      // ---- 학생 모드: 이동 "선택"만 기록 ----
      if (NetState.roomId && !NetState.isTeacher) {
        // 자신의 플레이어 엔티티 찾기
        const myPlayer = state.entities.find(
          e => e.type === "player" && e.id === NetState.playerId
        );
        if (!myPlayer) {
          addLog("내 캐릭터를 찾을 수 없습니다.");
          return;
        }

        const currentIndex = myPlayer.tileIndex;
        if (tileIndex === currentIndex) {
          addLog("현재 서 있는 타일은 다시 선택할 수 없습니다.");
          return;
        }

        const neighbors = getNeighborIndices(currentIndex);
        if (!neighbors.includes(tileIndex)) {
          addLog("인접한 타일만 이동 선택이 가능합니다.");
          return;
        }

        if (!NetState.movesRef || !NetState.playerId) {
          addLog("서버와의 연결이 아직 준비되지 않았습니다.");
          return;
        }

        // /rooms/{roomId}/moves/{playerId} = { region: tileIndex }
        NetState.movesRef.child(NetState.playerId).set({
          region: tileIndex
        });

        addLog(`다음 턴 이동 선택: #${currentIndex} → #${tileIndex}`);
        return; // 여기서 끝! 실제 이동은 교사가 턴을 진행할 때 처리
      }

      // ---- 아래는 기존 onTileClick 로직(교사용) 계속 ----
      // (네 코드에 있던 내용 그대로)
      
      if (!state.selectedPlayer) {
        selectPlayerOnTile(tileIndex);
        return;
      }
      const currentIndex = state.selectedPlayer.tileIndex;

      if (tileIndex === currentIndex) {
        clearSelection();
        return;
      }

      if (state.playersMovedThisTurn.has(state.selectedPlayer.id)) {
        addLog(
          `플레이어 ${state.selectedPlayer.id}는 이미 이 턴에 이동했습니다.`
        );
        updateSelectedPlayerInfo();
        return;
      }

      const neighbors = getNeighborIndices(currentIndex);

      if (neighbors.includes(tileIndex)) {
        const from = currentIndex;
        state.selectedPlayer.tileIndex = tileIndex;
        state.selectedPlayerTileIndex = tileIndex;

        state.playersMovedThisTurn.add(state.selectedPlayer.id);

        const prevEl = state.tileElements[from];
        const newEl = state.tileElements[tileIndex];
        if (prevEl && prevEl.overlay) prevEl.overlay.classList.remove("selected");
        if (newEl && newEl.overlay) newEl.overlay.classList.add("selected");

        renderAll();
        addLog(
          `플레이어 ${state.selectedPlayer.id}가 타일 #${from} → #${tileIndex} 로 이동했습니다. (이 턴 이동 완료)`
        );
        updateSelectedPlayerInfo();
        return;
      }

      const otherPlayer = state.entities.find(
        e => e.type === "player" && e.tileIndex === tileIndex
      );
      if (otherPlayer) {
        selectPlayerOnTile(tileIndex);
      }
    }

    // =========================
    // 8. 이동/감염/상자 로직
    // =========================
    function stepMovement() {
      const state = GameState;
      for (const e of state.entities) {
        if (e.type !== "citizen") continue;

        for (let step = 0; step < 2; step++) {
          // 이동 확률
          if (Math.random() < 0.7) {
            const nei = getNeighborIndices(e.tileIndex);
            if (nei.length > 0) { 
              e.tileIndex = nei[randInt(nei.length)];
            }
          }
        }
      }
    }

    function stepPlayerAutoMovement() {
      const state = GameState;
      const chestTiles = Array.from(state.activeChestTiles);
      if (chestTiles.length === 0) return;
      const N = GameConfig.NUM_TILES;
      const dist = new Array(N).fill(Infinity);
      const queue = [];
      for (const t of chestTiles) {
        dist[t] = 0;
        queue.push(t);
      }

      while (queue.length > 0) {
        const cur = queue.shift();
        const nd = dist[cur] + 1;
        const neighbors = getNeighborIndices(cur);
        for (const nb of neighbors) {
          if (nd < dist[nb]) {
            dist[nb] = nd;
            queue.push(nb);
          }
        }
      }

      const tileCitizenInfo = [...Array(N)].map(() => ({
        unvaccinated: 0,
        vaccinated: 0
      }));

      for (const e of state.entities) {
        if (e.type !== "citizen") continue;
        const info = tileCitizenInfo[e.tileIndex];
        if (e.vaccinated) info.vaccinated++;
        else info.unvaccinated++;
      }
      for (const p of state.entities) {
        if (p.type !== "player") continue;

        // ★ 실제 사람이 조종하는 말(교사/학생)은 자동 이동 제외
        if (p.isHuman) continue;
        }
        
        if (p.infected) continue; // 감염자는 자동 이동 없음
        const cur = p.tileIndex;
        if (state.activeChestTiles.has(cur)) continue;
        const neighbors = getNeighborIndices(cur);
        if (neighbors.length === 0) continue;
        if (!p.vaccinated) {
          let best = null;
          let bestDist = dist[cur];

          for (const nb of neighbors) {
            if (dist[nb] < bestDist) {
              bestDist = dist[nb];
              best = nb;
            }
          }

          if (best !== null && bestDist < Infinity) {
            p.tileIndex = best;
            state.playersMovedThisTurn.add(p.id);
          }
          continue;
        }
        let bestNb = null;
        let maxUnvaccinated = 0;
        for (const nb of neighbors) {
          const u = tileCitizenInfo[nb].unvaccinated;
          if (u > maxUnvaccinated) {
            maxUnvaccinated = u;
            bestNb = nb;
          }
        }

        if (bestNb !== null && maxUnvaccinated > 0) {
          p.tileIndex = bestNb;
          state.playersMovedThisTurn.add(p.id);
          continue;
        }

        const r = neighbors[randInt(neighbors.length)];
        p.tileIndex = r;
        state.playersMovedThisTurn.add(p.id);
      }
    }

    function stepInfection() {
      const {
        NUM_TILES,
        BASE_INFECTION_RATE,
        PLAYER_BASE_RATE,
        VACCINE_REDUCTION_FACTOR
      } = GameConfig;
      const state = GameState;

      const tilePop = [...Array(NUM_TILES)].map(() => ({
        citizens: [],
        players: []
      }));

      for (const e of state.entities) {
        if (e.type === "citizen") tilePop[e.tileIndex].citizens.push(e);
        else tilePop[e.tileIndex].players.push(e);
      }

      const citizenRate = BASE_INFECTION_RATE;
      const playerRate = PLAYER_BASE_RATE;
      let newInf = 0;

      for (let t = 0; t < NUM_TILES; t++) {
        const tile = tilePop[t];
        const citizens = tile.citizens;
        const players = tile.players;

        const infectedPlayers = players.filter(p => p.infected);
        const startInfCitizens = citizens.filter(c => c.infected);

        let healthy = citizens.filter(c => !c.infected);

        // 감염된 플레이어 → 시민 1명 감염 시도
        for (const p of infectedPlayers) {
          if (healthy.length === 0) break;
          const idx = randInt(healthy.length);
          const target = healthy[idx];
          const susceptibility = target.vaccinated ? VACCINE_REDUCTION_FACTOR : 1;
          const infectionProb = playerRate * susceptibility;
          if (!target.infected && Math.random() < playerRate) {
            target.infected = true;
            target.infectedTurn = GameState.currentTurn;
            newInf++;
          }
          healthy.splice(idx, 1);
        }

        // 감염된 시민 → 최대 2명 감염 시도 (80%)
        healthy = citizens.filter(c => !c.infected);
        for (const src of startInfCitizens) {
          for (let k = 0; k < 2; k++) {
            if (healthy.length === 0) break;
            const idx = randInt(healthy.length);
            const target = healthy[idx];
            const susceptibility = target.vaccinated ? VACCINE_REDUCTION_FACTOR : 1;
            const infectionProb = citizenRate * susceptibility;
            if (!target.infected && !target.recovered && Math.random() < infectionProb) {
              target.infected = true;
              target.infectedTurn = GameState.currentTurn;
              newInf++;
            }
            healthy.splice(idx, 1);
          }
        }
      }
      return newInf;
    }

    function stepRecovery() {
      const RECOVERY_TURNS = GameConfig.RECOVERY_TURNS;

      for (const e of GameState.entities) {
        // 시민만 회복 대상으로
        if (e.type !== "citizen") continue;

        // 아직 감염 중인 시민만
        if (!e.infected) continue;

        // 이미 회복 판정된 시민은 스킵
        if (e.recovered) continue;

        // 감염된 지 4턴 이상 지났으면 회복
        if (
          e.infectedTurn !== null &&
          GameState.currentTurn - e.infectedTurn >= RECOVERY_TURNS
        ) {
          e.infected = false;
          e.recovered = true;   // 재감염 방지 플래그
          e.infectedTurn = null;
        }
      }
    }

    function spawnChestsIfNeeded() {
      const state = GameState;
      if (!state.vaccineFeatureEnabled) return;
      if (areAllPlayersVaccinated()) return;
      if (state.currentTurn < 3) return;
      if ((state.currentTurn - 3) % 3 !== 0) return;

      const { NUM_TILES } = GameConfig;
      state.chestWave++;
      const toSpawn = state.chestWave;
      let spawned = 0;

      while (spawned < toSpawn && state.activeChestTiles.size < NUM_TILES) {
        const tileIndex = randInt(NUM_TILES);
        if (state.activeChestTiles.has(tileIndex)) continue;
        state.activeChestTiles.add(tileIndex);
        spawned++;
      }
      if (spawned > 0) {
        addLog(`보물상자 ${spawned}개가 랜덤 위치에 등장했습니다.`);
      }
    }

    function openChestsByPlayers() {
      const state = GameState;
      if (!state.vaccineFeatureEnabled) return;
      if (state.activeChestTiles.size === 0) return;

      let openedThisTurn = 0;
      const wasVaccineResearchStarted = state.openedChestCount > 0;

      for (const e of state.entities) {
        if (e.type !== "player" || e.infected) continue;
        const idx = e.tileIndex;
        if (state.activeChestTiles.has(idx)) {
          state.activeChestTiles.delete(idx);
          state.openedChestCount++;
          openedThisTurn++;

          if (state.openedChestCount === 1 && !wasVaccineResearchStarted) {
            addLog("첫 보물상자가 열려 백신 개발이 시작되었습니다.");
          }

          if (
            !state.vaccineActive &&
            state.openedChestCount >= GameConfig.CHESTS_REQUIRED_FOR_VACCINE
          ) {
            state.vaccineActive = true;
            addLog(
              "백신이 개발되었습니다! 이제 보물상자를 연 플레이어는 백신을 획득합니다."
            );
          }
          if (state.vaccineActive && !e.vaccinated) {
            e.vaccinated = true;
            addLog(`플레이어 ${e.id}가 백신을 획득했습니다.`);
            for (const c of state.entities) {
              if (c.type === "citizen" && c.tileIndex === idx) {
                c.vaccinated = true;
              }
            }
          }
        }
      } // 백신패치중

      if (openedThisTurn > 0) {
        addLog(
          `플레이어가 보물상자 ${openedThisTurn}개를 열었습니다. (누적: ${state.openedChestCount}개)`
        );
      }
    }

    // 교사 쪽에서 매 턴 끝나고 타일 요약 정보 만드는 함수
    function computeTileStats() {
      const { NUM_TILES } = GameConfig;
      const state = GameState;

      // 타일별 기본 구조
      const tiles = [...Array(NUM_TILES)].map(() => ({
        total: 0,
        infected: 0,
        vaccinatedCitizens: 0,
        hasChest: false
      }));

      // 시민/플레이어로부터 통계 쌓기
      for (const e of state.entities) {
        const t = tiles[e.tileIndex];
        t.total++;
        if (e.infected) t.infected++;

        if (e.type === "citizen" && e.vaccinated) {
          t.vaccinatedCitizens++;
        }
      }

      // 보물상자 위치 표시
      state.activeChestTiles.forEach(idx => {
        if (tiles[idx]) tiles[idx].hasChest = true;
      });

      return tiles;
    }

    // =========================
    // 9. 렌더링
    // =========================
    function renderTiles() {
      const { NUM_TILES } = GameConfig;
      const state = GameState;

      let tiles;
      let tileEntities;

      // =========================
      // 1) 학생 모드: 서버가 준 타일 요약값 사용
      // =========================
      if (NetState.roomId && !NetState.isTeacher && state.remoteTileStats) {
        tiles = state.remoteTileStats;

        // 학생은 시민 상태를 로컬에서 안 쓰고, 플레이어 말 표시만 필요
        tileEntities = [...Array(NUM_TILES)].map(() => ({
          players: [],
          citizens: []
        }));

        for (const e of state.entities) {
          if (e.type === "player") {
            tileEntities[e.tileIndex].players.push(e);
          }
        }
      }

      // 2) 교사/싱글 모드: 기존 방식 그대로

      else {
        tiles = [...Array(NUM_TILES)].map(() => ({
          total: 0,
          infected: 0,
          players: 0,
          vaccinatedCitizens: 0,
          hasChest: false
        }));
        tileEntities = [...Array(NUM_TILES)].map(() => ({
          players: [],
          citizens: []
        }));

        for (const e of state.entities) {
          const t = tiles[e.tileIndex];
          t.total++;
          if (e.infected) t.infected++;
          if (e.type === "player") {
            t.players++;
            tileEntities[e.tileIndex].players.push(e);
          } else {
            tileEntities[e.tileIndex].citizens.push(e);

            if (e.vaccinated) {
              t.vaccinatedCitizens++;
            }
          }
        }

        // 교사 쪽에서도 hasChest 플래그 세팅
        state.activeChestTiles.forEach(idx => {
          if (tiles[idx]) tiles[idx].hasChest = true;
        });
      }

      // 3) 실제 렌더링

      for (let i = 0; i < NUM_TILES; i++) {
        const t = tiles[i];
        const el = state.tileElements[i];
        if (!el) continue;

        el.pop.textContent = t.total;

        const hasChest =
          state.vaccineFeatureEnabled && !!t.hasChest;

        // SVG 타일 색칠
        if (hasChest) {
          el.path.style.fill = "rgba(200, 220, 255, 0.9)";
        } else {
          const infratio = t.total > 0 ? t.infected / t.total : 0;
          const vacRatio = t.total > 0 ? t.vaccinatedCitizens / t.total : 0;
        
          let baseR, baseG, baseB;
          if (infratio === 0) {
            baseR = 250;
            baseG = 250;
            baseB = 250;
          } else {
            baseR = 255;
            baseG = Math.round(250 * (1 - infratio));
            baseB = Math.round(250 * (1 - infratio));
          }

          const vaccineR = 0;
          const vaccineG = 220;
          const vaccineB = 0;

          const alpha = vacRatio; // 0 ~ 1 : 백신 비율이 곧 섞는 비율

          const r = Math.round(baseR * (1 - alpha) + vaccineR * alpha);
          const g = Math.round(baseG * (1 - alpha) + vaccineG * alpha);
          const b = Math.round(baseB * (1 - alpha) + vaccineB * alpha);

          el.path.style.fill = `rgb(${r}, ${g}, ${b})`;
        }

        // 말(토큰) 표시
        const pieceContainer = el.pieces;
        pieceContainer.innerHTML = "";

        const playersHere = tileEntities[i].players;
        playersHere.forEach(p => {
          const d = document.createElement("div");
          if (p.vaccinated) {
            d.className = "piece vaccinated";
          } else {
            d.className =
              "piece player" + (p.infected ? " infected" : "");
          }

          // ★ 내 말이면 주황색 테두리 추가
          if (NetState.playerId && p.id === NetState.playerId) {
            d.classList.add("me");
          }
          pieceContainer.appendChild(d);
        });
      }
    }

    function updateInfectedHistory() {
      const hist = GameState.historyCumulativeInfected;
      if (hist.length === 0) {
        UI.infectedHistoryBox.innerHTML =
          "<div><b>턴별 누적 감염 인구 (기록용)</b></div><div>아직 데이터가 없습니다.</div>";
        return;
      }
      let html = "<div><b>턴별 누적 감염 인구 (기록용)</b></div>";
      for (const h of hist) {
        html += `<div>T${h.turn}: ${h.infected}명</div>`;
      }
      UI.infectedHistoryBox.innerHTML = html;
    }

    function updateNewInfectedHistory() {
      const hist = GameState.historyNewInfected;
      if (hist.length === 0) {
        UI.newInfectedHistoryBox.innerHTML =
          "<div><b>턴별 신규 감염자 수 (기록용)</b></div><div>아직 데이터가 없습니다.</div>";
        return;
      }
      let html = "<div><b>턴별 신규 감염자 수 (기록용)</b></div>";
      for (const h of hist) {
        html += `<div>T${h.turn}: ${h.newInfected}명</div>`;
      }
      UI.newInfectedHistoryBox.innerHTML = html;
    }

    function renderStats() {
      const state = GameState;
      const total = GameConfig.NUM_CITIZENS + GameConfig.NUM_PLAYERS;

      let inf;

      // 학생 모드: 서버에서 받은 감염 수 사용
      if (NetState.roomId && !NetState.isTeacher && state.remoteInfectedTotal != null) {
        inf = state.remoteInfectedTotal;
      } else {
        // 교사/싱글 모드: 로컬 계산
        inf = computeInfectedCount();
      }

      UI.statInfected.textContent = inf;
      UI.statRatio.textContent = Math.round((inf / total) * 100) + "%";
      UI.statTurn.textContent = state.currentTurn;

      if (!state.vaccineFeatureEnabled) {
        UI.statOpenedChests.textContent = "-";
        UI.statVaccineStatus.textContent = "비활성화";
      } else {
        UI.statOpenedChests.textContent =
          `${state.openedChestCount} / ${GameConfig.CHESTS_REQUIRED_FOR_VACCINE}`;
        UI.statVaccineStatus.textContent = state.vaccineActive
          ? "개발 완료"
          : "개발 전";
      }

      // 교사/싱글 모드에서만 히스토리 배열에 새 항목 추가
      if (!(NetState.roomId && !NetState.isTeacher)) {
        if (state.lastRecordedTurn !== state.currentTurn) {
          state.historyCumulativeInfected.push({
            turn: state.currentTurn,
            infected: state.cumulativeInfectedTotal 
          });
          state.lastRecordedTurn = state.currentTurn;
          updateInfectedHistory();
        }
      }
    }

    function renderAll() {
      renderTiles();
      renderStats();
    }

    // =========================
    // 10. 새 게임 / 턴 진행
    // =========================
    function resetGame() {
      const state = GameState;
      state.currentTurn = 1;
      state.historyCumulativeInfected = [];
      state.historyNewInfected = [];
      state.lastRecordedTurn = 0;
      state.cumulativeInfectedTotal = 0;
      state.lastNewInfected = 0;
      state.lastReproductionIndex = 0;
      state.activeChestTiles = new Set();
      state.chestWave = 0;
      state.openedChestCount = 0;
      state.vaccineActive = false;
      state.playersMovedThisTurn = new Set();

      clearSelection();
      UI.logList.innerHTML = "";

      initEntities();
      renderAll();
      addInitialLog();
      updateNewInfectedHistory();
    }

    async function nextTurn() {
      const state = GameState;

      // 학생이면 턴 진행 금지
      if (NetState.roomId && !NetState.isTeacher) {
        addLog("이 방에서는 교사만 턴을 진행할 수 있습니다.");
        return;
      }

      // ---- 1) moves 읽어서 플레이어 이동 반영 (교사일 때) ----
      if (NetState.roomId && NetState.isTeacher && NetState.movesRef) {
        const movesSnap = await NetState.movesRef.get();
        const moves = movesSnap.val() || {};

        const players = state.entities.filter(e => e.type === "player");
        for (const p of players) {
          const m = moves[p.id];
          if (!m) continue;

          const dest = m.region;
          const neighbors = getNeighborIndices(p.tileIndex);
          if (neighbors.includes(dest)) {
            p.tileIndex = dest;
            addLog(`(적용) ${p.id} : #${p.tileIndex} → #${dest}`);
          }
        }

        // moves 초기화
        await NetState.movesRef.set(null);
      }
      // ---- 2) 기존 nextTurn 로직 그대로 ----

      state.currentTurn++;
      state.playersMovedThisTurn = new Set();

      spawnChestsIfNeeded();
      stepMovement();
      stepPlayerAutoMovement(); 
      openChestsByPlayers();
      spreadVaccineFromPlayers();
      const prevInfected = computeInfectedCount()
      const newInf = stepInfection();
      GameState.cumulativeInfectedTotal += newInf;
      
      GameState.historyNewInfected.push({
        turn: state.currentTurn,
        newInfected: newInf
      });
      updateNewInfectedHistory();
      
      stepRecovery();
      renderAll();
      updateSelectedPlayerInfo();
      addLog(`새 감염자 ${newInf}명`);

      // ---- 3) 교사라면 DB state 갱신 ----
      if (NetState.roomId && NetState.isTeacher && NetState.stateRef && NetState.playersRef) {
        const inf = computeInfectedCount();
        const tileStats = computeTileStats();

        // /rooms/{roomId}/state 업데이트
        await NetState.stateRef.set({
          turn: state.currentTurn,
          vaccineReady: state.vaccineActive,
          openedChests: state.openedChestCount,
          infectedTotal: inf,
          cumulativeHistory: state.historyCumulativeInfected,
          newHistory: state.historyNewInfected,
          tiles: tileStats
        });

        // /rooms/{roomId}/players/{playerId} 위치/상태 동기화
        const players = state.entities.filter(e => e.type === "player");
        for (const p of players) {
          await NetState.playersRef.child(p.id).update({
            tileIndex: p.tileIndex,
            infected: p.infected,
            vaccinated: p.vaccinated
          });
        }
      }
    }

    // =========================
    // 11. 초기화 & 이벤트 연결
    // =========================

    // 랜덤 방 ID 생성용 (간단 버전)
    function makeRandomRoomId() {
      return Math.random().toString(36).substring(2, 8).toUpperCase();
    }

    // 교사: 새 방 만들기
    async function createRoomAsTeacher(nickname) {
      const roomId = makeRandomRoomId();
      const roomRef = rtdb.ref("rooms/" + roomId);

      // 방 기본 state 기록
      await roomRef.set({
        createdAt: Date.now(),
        state: {
          turn: GameState.currentTurn,
          vaccineReady: GameState.vaccineActive,
          openedChests: GameState.openedChestCount || 0,
          infectedTotal: computeInfectedCount()
        }
      });

      NetState.roomId = roomId;
      NetState.isTeacher = true;
      NetState.nickname = nickname;
      NetState.roomRef = roomRef;
      NetState.playersRef = roomRef.child("players");
      NetState.movesRef = roomRef.child("moves");
      NetState.stateRef = roomRef.child("state");


      subscribeRoomState();
      subscribePlayers();
      alert(`방이 생성되었습니다!\n방 ID: ${roomId}\n이 코드를 학생들에게 알려주세요.`);
    }

    // 학생: 기존 방에 참가
    async function joinRoomAsStudent(nickname, roomId) {
      const roomRef = rtdb.ref("rooms/" + roomId);
      const snap = await roomRef.get();

      if (!snap.exists()) {
        alert("해당 방 ID가 존재하지 않습니다.");
        return;
      }

      NetState.roomId = roomId;
      NetState.isTeacher = false;
      NetState.nickname = nickname;
      NetState.roomRef = roomRef;
      NetState.playersRef = roomRef.child("players");
      NetState.movesRef = roomRef.child("moves");
      NetState.stateRef = roomRef.child("state");

      // 로컬 플레이어 엔티티 중 아직 안 써먹은 걸 하나 할당
      const freePlayer = GameState.entities.find(e => e.type === "player" && !e._reserved);
      if (!freePlayer) {
        alert("더 이상 할당 가능한 플레이어 말이 없습니다. (최대 인원 초과)");
        return;
      }
      freePlayer._reserved = true;
      NetState.playerId = freePlayer.id;

      await NetState.playersRef.child(freePlayer.id).set({
        name: nickname,
        role: "student",
        tileIndex: freePlayer.tileIndex,
        infected: freePlayer.infected,
        vaccinated: freePlayer.vaccinated
      });

      subscribeRoomState();
      subscribePlayers();

      alert(`방에 입장했습니다! (ID: ${roomId})`);
    }

    // =========================
    //  방 state 실시간 구독 (/rooms/{roomId}/state)
    // =========================
    function subscribeRoomState() {
      if (!NetState.stateRef) return;

      NetState.stateRef.on("value", snapshot => {
        const s = snapshot.val();
        if (!s) return;

        // 교사는 자기 로컬 state가 진짜라서, DB 값으로 덮어쓰지 않음
        if (NetState.isTeacher) return;

        // 기본 턴/백신/상자 정보
        GameState.currentTurn      = s.turn ?? GameState.currentTurn;
        GameState.openedChestCount = s.openedChests ?? GameState.openedChestCount;
        GameState.vaccineActive    = !!s.vaccineReady;

        // 서버에서 보낸 감염 총합
        GameState.remoteInfectedTotal = s.infectedTotal ?? null;

        // 히스토리(누적/신규)
        if (Array.isArray(s.cumulativeHistory)) {
          GameState.historyCumulativeInfected = s.cumulativeHistory;
        }
        if (Array.isArray(s.newHistory)) {
          GameState.historyNewInfected = s.newHistory;
        }

        // 타일 요약 정보
        if (Array.isArray(s.tiles)) {
          GameState.remoteTileStats = s.tiles;

          // 상자 위치도 여기서 세트로 재구성
          const chestSet = new Set();
          s.tiles.forEach((t, idx) => {
            if (t && t.hasChest) chestSet.add(idx);
          });
          GameState.activeChestTiles = chestSet;
        }

        // 히스토리 박스 다시 그리기
        updateInfectedHistory();
        updateNewInfectedHistory();

        renderAll();
        updateSelectedPlayerInfo();
      });
    }

    // =========================
    //  players 실시간 구독 (/rooms/{roomId}/players)
    // =========================
    function subscribePlayers() {
      if (!NetState.playersRef) return;

      NetState.playersRef.on("value", snapshot => {
        const playersObj = snapshot.val() || {};
        const allPlayers = GameState.entities.filter(e => e.type === "player");

        // DB에 있는 player 상태를 로컬 엔티티에 반영
        allPlayers.forEach(p => {
          const remote = playersObj[p.id];

          if (!remote) {
            // DB에 없으면 사람 안 붙은 AI 말로 취급
            p.isHuman = false;
            return;
          }

          p.tileIndex  = remote.tileIndex ?? p.tileIndex;
          p.infected   = !!remote.infected;
          p.vaccinated = !!remote.vaccinated;

          // ★ role 보고 사람 말인지 표시
          p.isHuman = remote.role === "student" || remote.role === "teacher";
        });

        renderAll();
        updateSelectedPlayerInfo();
      });
    }

    
    async function init() {
      await loadSVGMap();   // SVG 로드 끝날 때까지 기다림
      
        // SVG 로드 → 타일/이웃 설정 완료 후 엔티티 초기화
        initEntities();
        renderAll();
        addInitialLog();
        updateSelectedPlayerInfo();

        // === 멀티플레이: 역할 & 방 연결 ===
        const isTeacher = confirm("교사(방장)로 접속하시나요? 확인=예, 취소=아니오");
        const nickname = prompt("닉네임을 입력하세요", isTeacher ? "교사" : "학생");

        if (isTeacher) {
          await createRoomAsTeacher(nickname || "교사");
        } else {
          const roomId = prompt("참여할 방 ID를 입력하세요 (교사가 알려준 코드)");
          if (roomId) {
            await joinRoomAsStudent(nickname || "학생", roomId.trim());
          } else {
            alert("방 ID가 없어 싱글플레이 모드로 진행합니다.");
          }
        }

        // 버튼 리스너 연결
        UI.addDummyLogBtn.addEventListener("click", () =>
          addLog("테스트 로그")
        );
        UI.nextTurnBtn.addEventListener("click", nextTurn);
        UI.newGameBtn.addEventListener("click", resetGame);

        UI.vaccineToggle.addEventListener("change", () => {
          GameState.vaccineFeatureEnabled = UI.vaccineToggle.checked;
          if (!GameState.vaccineFeatureEnabled) {
            GameState.activeChestTiles = new Set();
            GameState.chestWave = 0;
            GameState.openedChestCount = 0;
            GameState.vaccineActive = false;
            addLog(
              "백신 시스템이 비활성화되었습니다."
            );
          } else {
            addLog(
              "백신 시스템이 활성화되었습니다. 3턴 이후부터 보물상자가 등장합니다."
            );
          }
          renderAll();
        });
    }

    init();
  </script>
</body>
</html>























