  <!DOCTYPE html>
  <html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>전염병 확산 게임 - v3.0 (SVG 169타일 · 말 시각화)</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      :root {
        --bg: #f5f5f7;
        --panel-bg: #ffffff;
        --border: #d0d0dd;
        --accent: #4a6fff;
        --text-main: #222222;
        --text-muted: #666666;
        --radius-lg: 16px;
        --shadow-soft: 0 10px 30px rgba(0, 0, 0, 0.05);
      }
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }
      body {
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        background: var(--bg);
        color: var(--text-main);
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: stretch;
      }
      .app {
        width: 100%;
        max-width: 1400px;
        min-height: 100vh;
        padding: 16px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      header {
        background: var(--panel-bg);
        border-radius: var(--radius-lg);
        padding: 12px 16px;
        box-shadow: var(--shadow-soft);
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        align-items: center;
        gap: 8px;
      }
      header h1 {
        font-size: 1.1rem;
        font-weight: 700;
      }
      .header-right {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: center;
        font-size: 0.85rem;
        color: var(--text-muted);
      }
      .badge {
        padding: 4px 8px;
        border-radius: 999px;
        background: #eef0ff;
        color: var(--accent);
        font-weight: 600;
        font-size: 0.75rem;
      }
      .btn {
        border: none;
        border-radius: 999px;
        padding: 6px 12px;
        font-size: 0.8rem;
        cursor: pointer;
        background: var(--accent);
        color: #fff;
        font-weight: 600;
        transition: transform 0.08s ease;
        box-shadow: 0 4px 12px rgba(74, 111, 255, 0.35);
      }
      .btn.secondary {
        background: #ececf5;
        color: var(--text-main);
        box-shadow: none;
      }
      .btn:hover {
        transform: translateY(-1px);
        box-shadow: 0 6px 16px rgba(74, 111, 255, 0.5);
      }
      main.layout {
        flex: 1;
        display: grid;
        grid-template-columns: minmax(0, 2.8fr) minmax(0, 1.2fr);
        gap: 12px;
        min-height: 0;
      }
      .map-panel {
        background: var(--panel-bg);
        border-radius: var(--radius-lg);
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        box-shadow: var(--shadow-soft);
      }
      .panel-header {
        display: flex;
        justify-content: space-between;
        font-size: 0.85rem;
      }
      .panel-header span:last-child {
        color: var(--text-muted);
      }

      /* ===== SVG 맵 컨테이너 ===== */
      .svg-map {
        position: relative;
        flex: 1;
        overflow: auto;
        background: #f9fafb;
        border-radius: 10px;
      }
      .svg-map svg {
        width: 100%;
        height: auto;
        display: block;
      }

      /* SVG 위에 덮는 오버레이 (말/텍스트) */
      #overlayLayer {
        position: absolute;
        inset: 0;
        pointer-events: none; /* 기본은 투명 레이어 */
      }

      .tile-overlay {
        position: absolute;
        transform: translate(-50%, -50%);
        font-size: 0.55rem;
        border-radius: 4px;
        padding: 2px 3px;
        border: none;
        pointer-events: auto; /* 이 박스는 클릭 허용 */
      }
      .tile-overlay.selected {
        box-shadow: 0 0 0 2px rgba(74, 111, 255, 0.7);
        border-color: var(--accent);
      }
      .tile-top {
        font-weight: 600;
        margin-bottom: 1px;
        display: flex;
        justify-content: space-between;
        gap: 4px;
      }
      .tile-bottom {
        display: flex;
        flex-direction: column;
        gap: 1px;
      }
      .tile-bottom span.label,
      .tile-bottom .pop {
        display: none !important;
      }

      .tile-pieces {
        margin-top: 1px;
        display: flex;
        flex-wrap: wrap;
        gap: 2px;
      }
      .piece {
        width: 20px;
        height: 20px;
        box-sizing: border-box;
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
        border: none;
      }
      .piece.player {
        background-image: url("./assets/player-normal.svg");
      }
      .piece.infected {
        background-image: url("./assets/player-infected.svg");
      }
      .piece.me {
        box-shadow: 0 0 0 2px #ff9800; /* 주황색 테두리 */
        border-radius: 50%;
      }
      /* ?해당부분 */
      .tile-fog {     
        position: absolute;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        font-size: 1rem;
        font-weight: 700;
        color: #000000;
        pointer-events: none;
      }
      .side-panel {
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .card {
        background: var(--panel-bg);
        border-radius: var(--radius-lg);
        padding: 10px 12px;
        box-shadow: var(--shadow-soft);
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .stats-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
      }
      .stat-item {
        border: 1px solid #ececf5;
        border-radius: 10px;
        padding: 8px;
        display: flex;
        flex-direction: column;
        gap: 2px;
        font-size: 0.8rem;
      }
      .stat-label {
        color: var(--text-muted);
        font-size: 0.75rem;
      }
      .stat-value {
        font-weight: 700;
        font-size: 0.95rem;
      }
      .stat-note {
        font-size: 0.7rem;
        color: var(--text-muted);
      }
      .stat-history {
        margin-top: 6px;
        padding-top: 6px;
        border-top: 1px dashed #ccc;
        font-size: 0.75rem;
        max-height: 120px;
        overflow-y: auto;
      }
      .log-list {
        list-style: none;
        max-height: 160px;
        overflow-y: auto;
        font-size: 0.8rem;
      }
      footer {
        font-size: 0.75rem;
        color: var(--text-muted);
        padding: 4px;
      }
      .toggle-label {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        font-size: 0.78rem;
      }
      /* ===== 퀴즈/스캔(레이더) 오버레이 ===== */
      .quiz-overlay {
        position: fixed;
        inset: 0;
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 2000;
      }
      .quiz-overlay.active {
        display: flex;
      }
      .quiz-backdrop {
        position: absolute;
        inset: 0;
        background: rgba(0, 0, 0, 0.4);
      }
      .quiz-box {
        position: relative;
        max-width: 520px;
        width: 90%;
        z-index: 2001;
      }
      .quiz-inner {
        background: var(--panel-bg);
        border-radius: 20px;
        padding: 20px 20px 16px;
        box-shadow: var(--shadow-soft);
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      .quiz-title {
        font-size: 0.95rem;
        font-weight: 700;
        margin-bottom: 4px;
      }
      .quiz-question {
        font-size: 0.9rem;
        line-height: 1.5;
      }
      .quiz-choices {
        margin-top: 8px;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .quiz-choice-btn {
        border: 1px solid var(--border);
        border-radius: 999px;
        padding: 8px 12px;
        background: #f5f5fb;
        font-size: 0.85rem;
        cursor: pointer;
        text-align: left;
      }
      .quiz-choice-btn:hover {
        background: #e4e6ff;
      }
      .quiz-footer {
        margin-top: 8px;
        display: flex;
        justify-content: flex-end;
      }

      /* 스캔 하이라이트용 연구소 타일 강조 */
      .scan-highlight {
        stroke: #ffd600;
        stroke-width: 4;
      }
    </style>
  </head>

  <body>
    <div class="app">
      <header>
        <h1>전염병 확산 게임 — 싱글플레이 프로토타입 v3.0</h1>
        <div class="header-right">
          <span class="badge">GitHub + Netlify 배포</span>
          <span>플레이어 25명 · 시민 30만명 · 타일 169개</span>
          <button class="btn secondary" id="addDummyLogBtn">테스트 로그 추가</button>
          <button class="btn secondary" id="newGameBtn">새 게임</button>
          <button class="btn secondary" id="switchGameModeBtn" style="display:none;">게임 모드 전환</button>
          <button class="btn secondary" id="scanBtn" style="display:none;">스캔(레이더)</button>
          <button class="btn" id="nextTurnBtn">다음 턴 진행</button>
        </div>
      </header>

      <main class="layout">
        <section class="map-panel">
          <div class="panel-header">
            <span>맵 (SVG 169 타일)</span>
            <span>정육각형 SVG 맵 · 6방향 이동</span>
          </div>

          <div class="svg-map" id="svgMapContainer">
            <!-- JS에서 map.svg 삽입 -->
            <div id="overlayLayer"></div>
          </div>
        </section>

        <section class="side-panel">
          <div class="card">
            <div class="stats-grid">
              <div class="stat-item">
                <div class="stat-label">전체 인구</div>
                <div class="stat-value" id="statTotal">525</div>
                <div class="stat-note">플레이어 25 + 시민 300000</div>
              </div>
              <div class="stat-item">
                <div class="stat-label">감염 인구</div>
                <div class="stat-value" id="statInfected">0</div>
                <div class="stat-note">플레이어 + 시민 합산</div>
              </div>
              <div class="stat-item">
                <div class="stat-label">감염률</div>
                <div class="stat-value" id="statRatio">0%</div>
                <div class="stat-note">전체 대비 비율</div>
              </div>
              <div class="stat-item">
                <div class="stat-label">현재 턴</div>
                <div class="stat-value" id="statTurn">1</div>
                <div class="stat-note">턴 제한 없음</div>
              </div>
              <div class="stat-item">
                <div class="stat-label">백신 개발률</div>
                <div class="stat-value" id="statOpenedChests">0%</div>
                <div class="stat-note">연구소 방문으로 증가/감소</div>
              </div>
              <div class="stat-item">
                <div class="stat-label">백신 상태</div>
                <div class="stat-value" id="statVaccineStatus">개발 전</div>
                <div class="stat-note">백신/연구소 시스템 사용 중</div>
              </div>
            </div>

            <div class="stat-history" id="infectedHistoryBox">
              <div><b>턴별 누적 감염 인구 (기록용)</b></div>
              <div>아직 데이터가 없습니다.</div>
            </div>

            <div class="stat-history" id="newInfectedHistoryBox">
              <div><b>턴별 신규 감염자 수 (기록용)</b></div>
              <div>아직 데이터가 없습니다.</div>
            </div>

            <div id="selectedPlayerInfo" style="margin-top:6px; font-size:0.78rem;">
              선택된 플레이어: 없음 (타일을 클릭해서 플레이어 선택/이동)
            </div>
          </div>

          <div class="card">
            <div style="font-weight:600">턴 로그</div>
            <ul class="log-list" id="logList"></ul>
          </div>
        </section>
      </main>

      <!-- 퀴즈/스캔(레이더) 오버레이 -->
      <div id="quizOverlay" class="quiz-overlay" style="display:none;">
        <div class="quiz-backdrop"></div>
        <div class="quiz-box">
          <div class="quiz-inner">
            <div class="quiz-title">스캔 문제</div>
            <div class="quiz-question" id="quizQuestionText">
              여기 문제 텍스트가 들어갑니다.
            </div>
            <div class="quiz-choices" id="quizChoices">
              <!-- JS에서 선택지 버튼 생성 -->
            </div>
            <div class="quiz-footer">
              <button class="btn secondary" id="quizCloseBtn">닫기</button>
            </div>
          </div>
        </div>
      </div>

      <footer>
        ※ 이 버전은 SVG 맵(169타일) 위에서 플레이어/시민을 시각화하고, 감염 확산 패턴과 연구소·백신 개발을 관찰하기 위한 프로토타입입니다.
      </footer>
    </div>


    <script src="https://www.gstatic.com/firebasejs/10.13.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.13.2/firebase-database-compat.js"></script>
    

    <script>
      // =========================
      // 0. Firebase 초기화 (Realtime DB)
      // =========================
      const firebaseConfig = {
        apiKey: "AIzaSyD78qp_t_LZnXEnPHnKoaXB9RYLIsu82K4",
        authDomain: "infectiongametest.firebaseapp.com",
        databaseURL: "https://infectiongametest-default-rtdb.firebaseio.com",
        projectId: "infectiongametest",
        storageBucket: "infectiongametest.firebasestorage.app",
        messagingSenderId: "1098044286154",
        appId: "1:1098044286154:web:69cb7e1512172a974d0033",
        measurementId: "G-G2TLQCTXSJ"
      };

      firebase.initializeApp(firebaseConfig);
      const rtdb = firebase.database();
        
      // =========================
      // 1. 설정 (Config)
      // =========================
      const GameConfig = {
        NUM_TILES: 169,         // SVG 타일 개수에 맞춤 (0~168)
        NUM_CITIZENS: 300000,   // 필요하면 여기서 시민 수 조절
        NUM_PLAYERS: 25,
        BASE_INFECTION_RATE: 0.55,   // 시민 감염 기본 55%
        PLAYER_BASE_RATE: 1.0,       // 감염된 플레이어 → 시민 감염 시도 확률
        VACCINE_REDUCTION_FACTOR: 0.05,
        RECOVERY_TURNS: 4,

        // 연구소 개수 & 백신 개발률 변화량
        LAB_COUNT: 5,
        VACCINE_PROGRESS_GAIN: 2,
        VACCINE_PROGRESS_LOSS: 18,

        // 2번째 게임(백신 접종 모드)용 설정
        MAX_VACCINE_DOSES_PER_PLAYER: 5, // 한 플레이어가 들고 다닐 수 있는 백신 최대 회수
        VACCINATIONS_PER_TURN: 2         // 한 턴에 한 플레이어가 접종할 수 있는 시민 수
      };

      const GameModes = {
        DEVELOPMENT: "development",   // 1편: 백신 개발 게임
        VACCINATION: "vaccination"    // 2편: 백신 접종 게임
      };

      // =========================
      // 2. 상태 (State)
      // =========================
      // ★★★ 여기서부터 GameState 전체 교체 ★★★
      const GameState = {
        currentTurn: 0,
        entities: [],

        gameMode: GameModes.DEVELOPMENT,  // 현재 게임 모드 (기본: 1편 - 백신 개발)

        historyCumulativeInfected: [],
        historyNewInfected: [],
        lastRecordedTurn: 0,
        cumulativeInfectedTotal: 0,

        // activeChestTiles = 연구소 위치 세트
        activeChestTiles: new Set(),
        openedChestCount: 0,   // "열린 상자 수" 대신 "백신 개발률(0~100)"로 사용
        vaccineActive: false,  // 백신 완성 여부
        

        vaccineFeatureEnabled: true,

        selectedPlayer: null,
        selectedPlayerTileIndex: null,
        playersMovedThisTurn: new Set(),

        tileElements: [],      // [index] -> { path, overlay, pop, pieces }
        tileCenters: [],       // [index] -> { x, y }
        neighborMap: [],       // [index] -> [neighborIndex ...]

        // 서버(교사)에서 받은 요약값 저장용
        remoteInfectedTotal: null,
        remoteTileStats: null,

        // ===== 퀴즈/스캔(레이더) 시스템 =====
        quizBank: [
          {
            id: "q1",
            type: "mcq",
            question: "우리 몸의 방어 작용은 두 가지로 구분된다. 무엇인가?",
            choices: ["선천 면역과 후천 면역", "세균성 면역과 바이러스성 면역", "자연 면역과 인공 면역"],
            answerIndex: 0
          },
          {
            id: "q2",
            type: "short",
            question: "큰포식세포가 병원체를 세포로 들여와 분해하는 과정을 무엇이라고 하는가?",
            answerText: "식세포작용"
          },
          {
            id: "q3",
            type: "short",
            question: "B림프구의 일부는 항체를 생성하고 분비하는 (              )(으)로 분화한다. 괄호 안에 들어갈 말은?",
            answerText: "형질세포"
          },
          {
            id: "q4",
            type: "mcq",
            question: "특정 항체가 특정 항원과만 결합하는 특성을 무엇이라고 하는가?",
            choices: ["면역 관용", "항원항체반응의 특이성", "항체 다양성"],
            answerIndex: 1
          },
          {
            id: "q5",
            type: "mcq",
            question: "백신 접종 후 형성되는 기억 세포의 주요 역할은 무엇인가?",
            choices: ["항원을 직접 파괴한다", "같은 병원체 재침입 시 빠른 면역 반응을 일으킨다", "체온을 낮춰 면역 반응을 억제한다"],
            answerIndex: 1
          },
          {
            id: "q6",
            type: "mcq",
            question: "핵산기반 백신의 특징으로 옳은 것은?",
            choices: ["약독화된 병원체를 직접 주입한다", "병원체의 유전 정보를 주사해서 몸속에서 항체를 만들게 한다", "항체를 직접 체내에 주입하는 방식이다"],
            answerIndex: 1
          },
          {
            id: "q7",
            type: "mcq",
            question: "2차 면역반응이 1차 면역반응보다 더 빠르고 강하게 일어나는 주된 이유는 무엇인가?",
            choices: ["항원이 체내에서 즉시 분해되기 때문이다", "기억 세포가 존재하여 항체 생성이 신속하게 일어난다", "1차 면역에서는 항체가 생성되지 않기 때문이다", "백혈구 수가 항상 항원보다 많기 때문이다"],
            answerIndex: 1
          },
          {
            id: "q8",
            type: "mcq",
            question: "다음 식을 간단히 한 값은 무엇인가?\n\n³√9 × √-12 × ³√81 × √-3",
            choices: ["-54", "54", "172", "1"],
            answerIndex: 0
          },
          {
            id: "q9",
            type: "mcq",
            question: "sinθ − cosθ = 1/2 일 때, 다음 식의 값은?\n\n8 sinθ cosθ",
            choices: ["1", "2", "3", "4"],
            answerIndex: 2
          },
          {
            id: "q10",
            type: "mcq",
            question: "100 이하의 자연수 중 11로 나누었을 때 나머지가 3인 수의 합은?",
            choices: ["684", "541", "500", "423"],
            answerIndex: 3
          },
          {
            id: "q11",
            type: "mcq",
            question: "다음 값을 구하시오. (상용로그)\n\nlog 100 + log₂ 8",
            choices: ["4", "5", "10", "13"],
            answerIndex: 1
          }
        ],
        activeQuizId: null,
        hasAnsweredQuiz: false,

        // 시야 밖 연구소 하이라이트 정보
        scanHighlightTileIndex: null,
        scanHighlightUntil: 0,   // Date.now() 기준 ms, 이 시각 이후 자동 해제

        // 이 학생(클라이언트) 기준으로 "이미 정답을 맞춘 퀴즈 ID" 모음
        quizSolvedCorrectly: new Set(),

        // 수신한 스캔의 startedAt (같은 이벤트 재처리 방지)
        lastScanStartedAt: 0,

        // 직전 턴 기준, 연구소까지 최소 거리 (힌트 중복 방지용)
        prevNearLabDistance: Infinity,

        // ===== 연구소 퀴즈(백신 개발용) 상태 =====
        // 현재 퀴즈가 어떤 용도인지: "scan" | "lab" | null
        quizContext: null,
        // 연구소 퀴즈에서 정답 시 적용할 개발률 변화량(+, - 포함)
        labQuizPendingDelta: 0,
        // 어느 플레이어가 퀴즈를 건 상태인지
        labQuizPendingPlayerId: null,
        // 어느 타일(연구소)에서 퀴즈가 걸렸는지
        labQuizPendingTileIndex: null,
        // 이 클라이언트가 마지막으로 받은 연구소 퀴즈 시작 시각
        lastLabQuizStartedAt: 0,
        // 교사 클라이언트가 마지막으로 처리한 연구소 퀴즈 결과 시각
        lastLabQuizResultAt: 0,
        // 교사(서버)가 결정한 연구소 퀴즈 결과를
        // 학생 쪽에서 중복 처리하지 않기 위한 타임스탬프
        lastLabServerResultAt: 0,

        // ★ 2번째 게임(접종 모드)에서
        //    "몇 번째 연구소 방문에서 나온 퀴즈인지" 저장 (2, 3 등)
        labQuizPendingVaccinationStage: 0
      };
      // ★★★ GameState 끝 ★★★

      // =========================
      // 네트워크/멀티플레이 상태
      // =========================
      // ★★★ 여기서부터 NetState 전체 교체 ★★★
      const NetState = {
        roomId: null,
        isTeacher: false,      // 교사(방장)인지
        playerId: null,        // 이 브라우저에 할당된 player 엔티티 id (예: "P3")
        nickname: null,

        roomRef: null,
        playersRef: null,
        movesRef: null,
        stateRef: null,
        scanRef: null,         // 스캔(레이더)용 퀴즈 상태 경로
        labQuizRef: null       // 연구소 퀴즈용 상태 경로
      };
      // ★★★ NetState 끝 ★★★
      
      // =========================
      // 3. UI 요소 참조 (DOM)
      // =========================
      // ★★★ 여기서부터 UI 객체 전체 교체 ★★★
      const UI = {
        svgMapContainer: document.getElementById("svgMapContainer"),
        overlayLayer: document.getElementById("overlayLayer"),
        hexGrid: null,

        logList: document.getElementById("logList"),
        statTurn: document.getElementById("statTurn"),
        statInfected: document.getElementById("statInfected"),
        statRatio: document.getElementById("statRatio"),
        statTotal: document.getElementById("statTotal"),
        statOpenedChests: document.getElementById("statOpenedChests"),
        statVaccineStatus: document.getElementById("statVaccineStatus"),
        infectedHistoryBox: document.getElementById("infectedHistoryBox"),
        newInfectedHistoryBox: document.getElementById("newInfectedHistoryBox"),
        selectedPlayerInfo: document.getElementById("selectedPlayerInfo"),
        addDummyLogBtn: document.getElementById("addDummyLogBtn"),
        nextTurnBtn: document.getElementById("nextTurnBtn"),
        newGameBtn: document.getElementById("newGameBtn"),
        switchGameModeBtn: document.getElementById("switchGameModeBtn"),

        // 스캔(레이더) 버튼 & 퀴즈 오버레이
        scanBtn: document.getElementById("scanBtn"),
        quizOverlay: document.getElementById("quizOverlay"),
        quizQuestionText: document.getElementById("quizQuestionText"),
        quizChoices: document.getElementById("quizChoices"),
        quizCloseBtn: document.getElementById("quizCloseBtn")
      };
      // ★★★ UI 객체 끝 ★★★

      UI.statTotal.textContent =
        GameConfig.NUM_CITIZENS + GameConfig.NUM_PLAYERS;

      // =========================
      // 4. 유틸 함수
      // =========================
      const randInt = max => Math.floor(Math.random() * max);

      function addLog(msg) {
        const li = document.createElement("li");
        li.textContent = `T${GameState.currentTurn} ${msg}`;
        UI.logList.appendChild(li);
        UI.logList.scrollTop = UI.logList.scrollHeight;
      }

      function addInitialLog() {
        const li = document.createElement("li");
        li.textContent =
          "T0 게임이 초기화되었습니다. 감염자 1명이 무작위 지정됨.";
        UI.logList.appendChild(li);
      }

      function computeInfectedCount() {
        return GameState.entities.filter(e => e.infected).length;
      }

      // =========================
      // 5. SVG 맵 로드 및 타일/이웃 설정
      // =========================
      function loadSVGMap() {
        return fetch("./assets/map.svg")
          .then(res => res.text())
          .then(svgText => {
            UI.svgMapContainer.insertAdjacentHTML("afterbegin", svgText);
            const svgElement = UI.svgMapContainer.querySelector("svg");
            if (!svgElement) {
              console.error("SVG를 찾을 수 없습니다.");
              return;
            }

            const paths = svgElement.querySelectorAll("path[data-tile-index]");
            const numTiles = paths.length;
            console.log("SVG 타일 개수:", numTiles);

            if (numTiles !== GameConfig.NUM_TILES) {
              console.warn(
                "GameConfig.NUM_TILES와 SVG 타일 수가 다릅니다. SVG 기준으로 맞춥니다."
              );
              GameConfig.NUM_TILES = numTiles;
            }

            let vb = svgElement.getAttribute("viewBox");
            let viewW = 2300, viewH = 2006;
            if (vb) {
              const parts = vb.split(/\s+/).map(Number);
              if (parts.length === 4) {
                viewW = parts[2];
                viewH = parts[3];
              }
            }

            GameState.tileCenters = new Array(GameConfig.NUM_TILES);
            paths.forEach(p => {
              const idx = parseInt(p.getAttribute("data-tile-index"), 10);
              const box = p.getBBox();
              const cx = box.x + box.width / 2;
              const cy = box.y + box.height / 2;
              GameState.tileCenters[idx] = { x: cx, y: cy };
            });

            GameState.tileElements = new Array(GameConfig.NUM_TILES);
            for (let i = 0; i < GameConfig.NUM_TILES; i++) {
              const path = svgElement.querySelector(`path[data-tile-index="${i}"]`);
              if (!path) continue;

              // ★ 타일 전체를 덮는 fogPath(SVG 레이어) 생성
              const fogPath = path.cloneNode(false);
              fogPath.removeAttribute("data-tile-index");
              fogPath.style.fill = "rgba(0, 0, 0, 0.1)";
              fogPath.style.pointerEvents = "none";
              fogPath.style.display = "none";
              path.parentNode.appendChild(fogPath);

              const center = GameState.tileCenters[i];
              const leftPercent = (center.x / viewW) * 100;
              const topPercent = (center.y / viewH) * 100;

              const overlay = document.createElement("div");
              overlay.className = "tile-overlay";
              overlay.style.left = leftPercent + "%";
              overlay.style.top = topPercent + "%";
              overlay.dataset.tileIndex = i;

              overlay.innerHTML = `
                <div class="tile-bottom">
                  <div class="tile-fog">?</div>
                  <div><span class="label">인구:</span> <span class="pop">0</span></div>
                  <div class="tile-pieces"></div>
                </div>
              `;

              overlay.addEventListener("click", (e) => {
                e.stopPropagation();
                onTileClick(i);
              });
              path.addEventListener("click", (e) => {
                e.stopPropagation();
                onTileClick(i);
              });

              UI.overlayLayer.appendChild(overlay);

              GameState.tileElements[i] = {
                path,
                overlay,
                pop: overlay.querySelector(".pop"),
                pieces: overlay.querySelector(".tile-pieces"),
                fog: overlay.querySelector(".tile-fog"),
                fogPath   // ← 타일 전체 반투명 커버
              };
            }

            buildNeighborMap();
            console.log("SVG 기반 이웃 관계 설정 완료");
          })
          .catch(err => console.error("SVG 로드 오류:", err));
      }

      function buildNeighborMap() {
        const N = GameConfig.NUM_TILES;
        const centers = GameState.tileCenters;
        GameState.neighborMap = new Array(N);

        for (let i = 0; i < N; i++) {
          const ci = centers[i];
          if (!ci) continue;

          const dists = [];
          for (let j = 0; j < N; j++) {
            if (i === j) continue;
            const cj = centers[j];
            if (!cj) continue;
            const dx = cj.x - ci.x;
            const dy = cj.y - ci.y;
            const dist2 = dx * dx + dy * dy;
            dists.push({ j, dist2 });
          }

          dists.sort((a, b) => a.dist2 - b.dist2);
          if (dists.length === 0) {
            GameState.neighborMap[i] = [];
            continue;
          }

          const baseDist2 = dists[0].dist2;
          const threshold = baseDist2 * 2.25;

          const neighbors = [];
          for (const d of dists) {
            if (d.dist2 <= threshold && neighbors.length < 6) {
              neighbors.push(d.j);
            }
          }
          GameState.neighborMap[i] = neighbors;
        }
      }

      // 타일 간 최소 이동 칸수(BFS 기반 거리 계산)
      function getTileDistance(a, b, maxDepth = Infinity) {
        if (a === b) return 0;

        const visited = new Set();
        visited.add(a);

        let frontier = [a];
        let dist = 0;

        while (frontier.length > 0 && dist < maxDepth) {
          dist++;
          const next = [];

          for (const cur of frontier) {
            const neighbors = getNeighborIndices(cur);
            for (const nb of neighbors) {
              if (nb === b) {
                return dist;
              }
              if (!visited.has(nb)) {
                visited.add(nb);
                next.push(nb);
              }
            }
          }

          frontier = next;
        }

        return Infinity;
      }

      function getNeighborIndices(i) {
        return GameState.neighborMap[i] || [];
      }

      // 연구소(센터) 초기화
      function initLabs() {
        const state = GameState;
        const { NUM_TILES, LAB_COUNT } = GameConfig;

        state.activeChestTiles = new Set();
        const targetCount = LAB_COUNT || 5;

        const maxAttempts = NUM_TILES * 20;
        let attempts = 0;

        while (state.activeChestTiles.size < targetCount && attempts < maxAttempts) {
          attempts++;
          const candidate = randInt(NUM_TILES);

          let ok = true;
          for (const existing of state.activeChestTiles) {
            const dist = getTileDistance(candidate, existing, 3);
            if (dist <= 3) {
              ok = false;
              break;
            }
          }

          if (!ok) continue;
          state.activeChestTiles.add(candidate);
        }

        if (state.activeChestTiles.size < targetCount) {
          console.warn("서로 4칸 이상 떨어진 연구소 배치가 완전히 되지 않았습니다.");
          while (state.activeChestTiles.size < targetCount) {
            state.activeChestTiles.add(randInt(NUM_TILES));
          }
        }

        console.log("연구소(센터) 위치:", Array.from(state.activeChestTiles));
      }

      // =========================
      // 6. 엔티티 초기화
      // =========================
      function initEntities() {
        const { NUM_CITIZENS, NUM_PLAYERS, NUM_TILES } = GameConfig;
        const ents = [];

        // 시민 생성 (그대로)
        for (let i = 0; i < NUM_CITIZENS; i++) {
          ents.push({
            id: "C" + i,
            type: "citizen",
            tileIndex: randInt(NUM_TILES),
            infected: false,
            infectedTurn: null,
            recovered: false,
            vaccinated: false
          });
        }

        // 플레이어 생성: 서로 최소 2칸 이상 떨어진 위치에 스폰
        const chosenPlayerTiles = [];

        for (let i = 0; i < NUM_PLAYERS; i++) {
          let tile = randInt(NUM_TILES);
          let attempts = 0;

          while (attempts < 500) {
            tile = randInt(NUM_TILES);
            let ok = true;

            for (const prev of chosenPlayerTiles) {
              const dist = getTileDistance(tile, prev, 2); 
              if (dist < 2) {
                ok = false;
                break;
              }
            }

            if (ok) break;
            attempts++;
          }

          chosenPlayerTiles.push(tile);

          ents.push({
            id: "P" + i,
            type: "player",
            tileIndex: tile,
            infected: false,
            visitedLabs: new Set(),
            vaccinated: false,
            hasVaccine: false,
            enhancedVaccine: false
          });
        }

        // 무작위 플레이어 1명 감염
        const randP = NUM_CITIZENS + randInt(NUM_PLAYERS);
        ents[randP].infected = true;
        ents[randP].infectedTurn = 0;

        GameState.cumulativeInfectedTotal = 1;
        GameState.entities = ents;
      }
      
      // =========================
      // 7. 플레이어 선택/이동
      // =========================
      function updateSelectedPlayerInfo() {
        const { selectedPlayer, playersMovedThisTurn } = GameState;
        if (!selectedPlayer) {
          UI.selectedPlayerInfo.textContent =
            "선택된 플레이어: 없음 (타일을 클릭해서 플레이어 선택)";
          return;
        }
        const movedFlag = playersMovedThisTurn.has(selectedPlayer.id)
          ? " / 이 턴 이동 완료"
          : " / 이 턴 이동 가능";
        UI.selectedPlayerInfo.textContent =
          `선택된 플레이어: ${selectedPlayer.id} (현재 타일 #${selectedPlayer.tileIndex})${movedFlag}`;
      }

      function clearSelection() {
        if (GameState.selectedPlayerTileIndex !== null) {
          const el = GameState.tileElements[GameState.selectedPlayerTileIndex];
          if (el && el.overlay) {
            el.overlay.classList.remove("selected");
          }
        }
        GameState.selectedPlayer = null;
        GameState.selectedPlayerTileIndex = null;
        updateSelectedPlayerInfo();
      }

      function selectPlayerOnTile(tileIndex) {
        const player = GameState.entities.find(
          e => e.type === "player" && e.tileIndex === tileIndex
        );
        if (!player) {
          clearSelection();
          return;
        }
        if (GameState.selectedPlayerTileIndex !== null) {
          const prevEl = GameState.tileElements[GameState.selectedPlayerTileIndex];
          if (prevEl && prevEl.overlay) {
            prevEl.overlay.classList.remove("selected");
          }
        }
        GameState.selectedPlayer = player;
        GameState.selectedPlayerTileIndex = tileIndex;
        const newEl = GameState.tileElements[tileIndex];
        if (newEl && newEl.overlay) {
          newEl.overlay.classList.add("selected");
        }
        updateSelectedPlayerInfo();
      }

      function onTileClick(tileIndex) {
        const state = GameState;

        if (NetState.roomId && !NetState.isTeacher) {
          const myPlayer = state.entities.find(
            e => e.type === "player" && e.id === NetState.playerId
          );
          if (!myPlayer) {
            addLog("내 캐릭터를 찾을 수 없습니다.");
            return;
          }

          const currentIndex = myPlayer.tileIndex;
          if (tileIndex === currentIndex) {
            addLog("현재 서 있는 타일은 다시 선택할 수 없습니다.");
            return;
          }

          // ★ 게임 모드 & 강화 백신 여부에 따라 이동 가능 최대 칸 수 결정
          let maxStep = 1;
          if (
            state.gameMode === GameModes.VACCINATION &&
            myPlayer.enhancedVaccine
          ) {
            maxStep = 2;
          }

          // ★ 1칸 또는 2칸 이내로 도달 가능한 타일 집합 계산
          const neighbors1 = getNeighborIndices(currentIndex);
          const reachable = new Set();
          neighbors1.forEach(n => reachable.add(n));

          if (maxStep >= 2) {
            neighbors1.forEach(n => {
              getNeighborIndices(n).forEach(nn => {
                if (nn !== currentIndex) reachable.add(nn);
              });
            });
          }

          if (!reachable.has(tileIndex)) {
            if (maxStep === 1) {
              addLog("인접한 타일만 이동 선택이 가능합니다.");
            } else {
              addLog("이동 가능한 범위(최대 2칸) 내의 타일만 선택이 가능합니다.");
            }
            return;
          }

          if (!NetState.movesRef || !NetState.playerId) {
            addLog("서버와의 연결이 아직 준비되지 않았습니다.");
            return;
          }

          NetState.movesRef.child(NetState.playerId).set({
            region: tileIndex
          });

          addLog(`다음 턴 이동 선택: #${currentIndex} → #${tileIndex}`);
          return;
        }

        if (!state.selectedPlayer) {
          selectPlayerOnTile(tileIndex);
          return;
        }
        const currentIndex = state.selectedPlayer.tileIndex;

        if (tileIndex === currentIndex) {
          clearSelection();
          return;
        }

        if (state.playersMovedThisTurn.has(state.selectedPlayer.id)) {
          addLog(
            `플레이어 ${state.selectedPlayer.id}는 이미 이 턴에 이동했습니다.`
          );
          updateSelectedPlayerInfo();
          return;
        }

        const neighbors = getNeighborIndices(currentIndex);

        // 이동 가능한 최대 칸 수:
        //  - 기본: 1칸
        //  - 2번째 게임에서 강화 백신 보유(enhancedVaccine=true): 2칸
        let maxStep = 1;
        if (
          state.gameMode === GameModes.VACCINATION &&
          state.selectedPlayer.enhancedVaccine
        ) {
          maxStep = 2;
        }

        // 도달 가능한 타일 집합 계산
        const reachable = new Set();
        const n1 = getNeighborIndices(currentIndex);
        n1.forEach(n => reachable.add(n));

        if (maxStep >= 2) {
          n1.forEach(n => {
            getNeighborIndices(n).forEach(nn => {
              if (nn !== currentIndex) reachable.add(nn);
            });
          });
        }

        if (reachable.has(tileIndex)) {
          const from = currentIndex;
          state.selectedPlayer.tileIndex = tileIndex;
          state.selectedPlayerTileIndex = tileIndex;

          state.playersMovedThisTurn.add(state.selectedPlayer.id);

          const prevEl = state.tileElements[from];
          const newEl = state.tileElements[tileIndex];
          if (prevEl && prevEl.overlay) prevEl.overlay.classList.remove("selected");
          if (newEl && newEl.overlay) newEl.overlay.classList.add("selected");

          renderAll();
          addLog(
            `플레이어 ${state.selectedPlayer.id}가 타일 #${from} → #${tileIndex} 로 이동했습니다. (이 턴 이동 완료)`
          );
          updateSelectedPlayerInfo();
          return;
        }

        const otherPlayer = state.entities.find(
          e => e.type === "player" && e.tileIndex === tileIndex
        );
        if (otherPlayer) {
          selectPlayerOnTile(tileIndex);
        }
      }


      // =========================
      // 8. 이동/감염/연구소(센터) 로직
      // =========================
      function stepMovement() {
        const state = GameState;
        for (const e of state.entities) {
          if (e.type !== "citizen") continue;

          for (let step = 0; step < 2; step++) {
            if (Math.random() < 0.7) {
              const nei = getNeighborIndices(e.tileIndex);
              if (nei.length > 0) { 
                e.tileIndex = nei[randInt(nei.length)];
              }
            }
          }
        }
      }

      function stepPlayerAutoMovement() {
        const state = GameState;
        const N = GameConfig.NUM_TILES;

        // 멀티플레이에서 학생 브라우저에서는 자동 이동을 절대 실행하지 않음
        if (NetState.roomId && !NetState.isTeacher) {
          return;
        }

        // ──────────────────────────────
        // 0. 타일별 "백신이 아직 필요한 시민 수" 계산
        //    (감염 X, 회복 X, 접종 X 인 시민)
        // ──────────────────────────────
        const tileNeed = Array(N).fill(0);
        for (const e of state.entities) {
          if (e.type !== "citizen") continue;
          if (!e.infected && !e.recovered && !e.vaccinated) {
            tileNeed[e.tileIndex]++;
          }
        }

        const allLabs = Array.from(state.activeChestTiles || []);

        // 연구소가 하나도 없으면 그냥 랜덤 워크
        if (allLabs.length === 0) {
          for (const p of state.entities) {
            if (p.type !== "player") continue;
            if (p.isHuman) continue;
            if (state.playersMovedThisTurn && state.playersMovedThisTurn.has(p.id)) continue;

            const neighbors = getNeighborIndices(p.tileIndex);
            if (neighbors.length === 0) continue;

            const r = neighbors[randInt(neighbors.length)];
            p.tileIndex = r;
            state.playersMovedThisTurn.add(p.id);
          }
          return;
        }

        for (const p of state.entities) {
          if (p.type !== "player") continue;
          if (p.isHuman) continue; // 학생/교사가 조종하는 말은 자동 이동 금지
          if (state.playersMovedThisTurn && state.playersMovedThisTurn.has(p.id)) continue;

          if (!p.visitedLabs) {
            p.visitedLabs = new Set();
          }

          const neighbors = getNeighborIndices(p.tileIndex);
          if (neighbors.length === 0) continue;

          // ──────────────────────────────
          // A. 2번째 게임(VACCINATION 모드) 전용 로직
          //    1) 감염된 AI 플레이어: 백신 미접종 시민이 많은 방향으로 이동
          //    2) 비감염 + 강화 백신 보유(enhancedVaccine=true)인 경우도
          //       같은 방식으로 "필요 시민 많은 곳"을 향해 이동
          // ──────────────────────────────
          if (state.gameMode === GameModes.VACCINATION) {
            if (p.infected || p.enhancedVaccine) {
              let best = null;
              let bestScore = -1;

              // 각 이웃 타일에 대해 스코어 계산
              for (const nb of neighbors) {
                // 기본 점수: 그 타일에 있는 미접종 시민 수
                let score = tileNeed[nb];

                // 보너스: 그 타일의 이웃 타일까지 조금 반영 (근처 밀집 지역으로 유도)
                const nbNeighbors = getNeighborIndices(nb);
                for (const nn of nbNeighbors) {
                  score += tileNeed[nn] * 0.5;
                }

                if (score > bestScore) {
                  bestScore = score;
                  best = nb;
                }
              }

              // 모두 점수가 0이라면 아무 데나 랜덤 이동
              if (best === null) {
                best = neighbors[randInt(neighbors.length)];
              }

              p.tileIndex = best;
              state.playersMovedThisTurn.add(p.id);
              continue; // 연구소 타깃 로직은 쓰지 않음
            }
          }

          // ──────────────────────────────
          // B. 나머지 플레이어(AI)는
          //    "아직 방문하지 않은 연구소"를 향해 자동 이동
          //    (1편/2편 공통 기본 행동)
          // ──────────────────────────────
          const targetLabs = allLabs.filter(idx => !p.visitedLabs.has(idx));

          if (targetLabs.length === 0) {
            // 더 이상 갈 연구소가 없으면 랜덤 워크
            const r = neighbors[randInt(neighbors.length)];
            p.tileIndex = r;
            state.playersMovedThisTurn.add(p.id);
            continue;
          }

          // 연구소들로부터의 BFS 거리 필드 계산 (multi-source BFS)
          const dist = new Array(N).fill(Infinity);
          const queue = [];

          for (const t of targetLabs) {
            dist[t] = 0;
            queue.push(t);
          }

          while (queue.length > 0) {
            const cur = queue.shift();
            const nd = dist[cur] + 1;
            const nbs = getNeighborIndices(cur);
            for (const nb of nbs) {
              if (nd < dist[nb]) {
                dist[nb] = nd;
                queue.push(nb);
              }
            }
          }

          const cur = p.tileIndex;
          let best = null;
          let bestDist = dist[cur];

          for (const nb of neighbors) {
            if (dist[nb] < bestDist) {
              bestDist = dist[nb];
              best = nb;
            }
          }

          if (best !== null && bestDist < Infinity) {
            p.tileIndex = best;
          } else {
            const r = neighbors[randInt(neighbors.length)];
            p.tileIndex = r;
          }

          state.playersMovedThisTurn.add(p.id);
        }
      }

      // 연구소에 있는 플레이어들로부터 효과 적용
      //  - 1편(개발 모드): 연구소에 도착하면 퀴즈를 풀고, 정답 시에만 백신 개발률 up/down
      //  - 2편(접종 모드): 연구소 방문 횟수에 따라 영구 백신 획득 + 업그레이드
      function applyLabEffects() {
        const state = GameState;
        if (!state.vaccineFeatureEnabled) return;

        // ──────────────────────────────
        // 1편: 백신 개발 모드
        //  - 연구소에 도착한 플레이어는 퀴즈를 풀고,
        //    정답을 맞혀야 백신 개발률이 변한다.
        // ──────────────────────────────
        if (state.gameMode === GameModes.DEVELOPMENT) {
          // 이미 백신이 완성되었다면 더 이상 처리하지 않음
          if (state.vaccineActive) return;

          const gain = GameConfig.VACCINE_PROGRESS_GAIN || 5;
          const loss = GameConfig.VACCINE_PROGRESS_LOSS || 25;

          // 연구소 타일 위에 있는 플레이어 중
          // 아직 그 연구소를 방문 처리하지 않은 첫 번째 플레이어를 찾는다.
          for (const e of state.entities) {
            if (e.type !== "player") continue;
            if (!state.activeChestTiles.has(e.tileIndex)) continue;

            if (!e.visitedLabs) {
              e.visitedLabs = new Set();
            }
            if (e.visitedLabs.has(e.tileIndex)) {
              continue;
            }

            const delta = e.infected ? -loss : gain;

            // 멀티플레이가 아닐 때는 모두 사람이 조종하는 말로 보고 퀴즈를 출제한다.
            // 멀티플레이일 때만, AI 말에 한해 퀴즈 없이 즉시 보상 처리.
            const isMultiplay = NetState.roomId && NetState.playersRef;
            const treatAsHuman = !isMultiplay || e.isHuman;

            // ★ AI 말은 퀴즈 없이 즉시 보상 처리 (멀티플레이 방에서만)
            if (!treatAsHuman) {
              state.openedChestCount = Math.max(
                0,
                Math.min(100, state.openedChestCount + delta)
              );
              e.visitedLabs.add(e.tileIndex);
              addLog(
                `플레이어 ${e.id}가 연구소를 분석해 백신 개발률이 ${delta > 0 ? "+" + delta : delta}% 변화했습니다. (현재 ${state.openedChestCount}%)`
              );
              if (state.openedChestCount >= 100 && !state.vaccineActive) {
                state.vaccineActive = true;
                addLog("백신이 완성되었습니다! 그런데.. 백신 접종은 어떻게 하죠?");
              }
              continue; // 이 플레이어 처리는 끝
            }

            // ① 멀티플레이 + 교사: 해당 플레이어(학생)에게만 퀴즈 전송
            if (NetState.roomId && NetState.isTeacher && NetState.labQuizRef) {
              const bank = state.quizBank || [];
              if (!bank.length) {
                // 퀴즈가 아예 없으면 예전 방식대로 바로 적용
                state.openedChestCount = Math.max(
                  0,
                  Math.min(100, state.openedChestCount + delta)
                );
                e.visitedLabs.add(e.tileIndex);
                addLog(
                  `플레이어 ${e.id}가 연구소를 방문해 백신 개발률이 ${delta > 0 ? "+" + delta : delta}% 변화했습니다. (현재 ${state.openedChestCount}%)`
                );
                if (state.openedChestCount >= 100 && !state.vaccineActive) {
                  state.vaccineActive = true;
                  addLog("백신이 완성되었습니다! 그런데.. 백신 접종은 어떻게 하죠?");
                }
                return;
              }

              const quiz = bank[Math.floor(Math.random() * bank.length)];
              const startedAt = Date.now();

              state.activeQuizId = quiz.id;
              state.hasAnsweredQuiz = false;
              state.quizContext = "lab";
              state.labQuizPendingDelta = delta;
              state.labQuizPendingPlayerId = e.id;
              state.labQuizPendingTileIndex = e.tileIndex;

              NetState.labQuizRef.set({
                quizId: quiz.id,
                targetPlayerId: e.id,
                startedAt,
                delta
              });

              addLog(
                `플레이어 ${e.id}가 연구소에 도착했습니다. 해당 학생 화면에 연구소 퀴즈가 출제됩니다.`
              );
              return; // 한 번에 한 연구소 퀴즈만 처리
            }

            // ② 싱글플레이(또는 방 없이 교사만 있을 때): 로컬에서 바로 퀴즈 표시
            startLabQuizForPlayerLocal(e, delta);
            return;
          }

          return;
        }

        // ──────────────────────────────
        // 2편: 백신 접종 모드
        //  - 서로 다른 연구소 방문 횟수에 따라 백신 획득
        //  - 2번째/3번째 연구소에서는 "해당 학생만 퀴즈를 풀고,
        //    정답일 때만 백신/업그레이드 적용"
        // ──────────────────────────────
        if (state.gameMode === GameModes.VACCINATION) {
          for (const e of state.entities) {
            if (e.type !== "player") continue;
            if (!state.activeChestTiles.has(e.tileIndex)) continue;

            // 연구소 방문 기록 세트 보장
            if (!e.visitedLabs) {
              e.visitedLabs = new Set();
            }

            // 이미 이 연구소는 사용한 적이 있으면 효과 없음
            if (e.visitedLabs.has(e.tileIndex)) {
              continue;
            }

            // 이번에 처음 방문한 연구소로 표시 (중복 퀴즈 방지용)
            e.visitedLabs.add(e.tileIndex);
            const visitedCount = e.visitedLabs.size;

            // 1번째 연구소: 스토리용 안내만, 퀴즈 없이 바로 로그
            if (visitedCount === 1) {
              addLog(
                `플레이어 ${e.id}가 첫 번째 연구소에 도착했습니다. 오래된 기록 속에서 백신의 단서를 찾고 있습니다.`
              );
              continue;
            }

            const stage = visitedCount; // 2 또는 3

            // 멀티플레이가 아닐 때는 모두 사람이 조종하는 말로 보고 퀴즈를 출제한다.
            // 멀티플레이일 때만, AI 말에 한해 퀴즈 없이 즉시 보상 처리.
            const isMultiplay = NetState.roomId && NetState.playersRef;
            const treatAsHuman = !isMultiplay || e.isHuman;

            // ★ AI 말은 퀴즈 없이 즉시 보상 처리 (멀티플레이 방에서만)
            if (!treatAsHuman) {
              applyVaccinationRewardImmediate(e, stage);
              continue;
            }

            // 2번째, 3번째 연구소: 퀴즈를 맞혀야 백신/업그레이드 적용
            // ① 멀티플레이 + 교사: 해당 플레이어(학생)에게만 퀴즈 전송
            if (NetState.roomId && NetState.isTeacher && NetState.labQuizRef) {
              const bank = state.quizBank || [];
              if (!bank.length) {
                // 퀴즈가 없으면 예전 로직 그대로 즉시 처리
                applyVaccinationRewardImmediate(e, stage);
                return;
              }

              const quiz = bank[Math.floor(Math.random() * bank.length)];
              const startedAt = Date.now();

              state.activeQuizId = quiz.id;
              state.hasAnsweredQuiz = false;
              state.quizContext = "lab";
              state.labQuizPendingPlayerId = e.id;
              state.labQuizPendingTileIndex = e.tileIndex;
              state.labQuizPendingVaccinationStage = stage;

              NetState.labQuizRef.set({
                quizId: quiz.id,
                targetPlayerId: e.id,
                startedAt,
                stage,
                mode: "vaccination"
              });

              if (stage === 2) {
                addLog(
                  `플레이어 ${e.id}가 두 번째 연구소에 도착했습니다. 해당 학생 화면에 백신 단서 퀴즈가 출제됩니다.`
                );
              } else if (stage === 3) {
                addLog(
                  `플레이어 ${e.id}가 세 번째 연구소에 도착했습니다. 해당 학생 화면에 최종 백신 시스템 퀴즈가 출제됩니다.`
                );
              }
              return; // 한 번에 한 연구소 퀴즈만 처리
            }

            // ② 싱글플레이(또는 방 없이 교사만 있을 때): 로컬에서 퀴즈 표시
            startVaccineLabQuizForPlayerLocal(e, stage);
            return;
          }

          return;
        }
      }


      function stepInfection() {
        const {
          NUM_TILES,
          BASE_INFECTION_RATE,
          PLAYER_BASE_RATE
        } = GameConfig;
        const state = GameState;

        const tilePop = [...Array(NUM_TILES)].map(() => ({
          citizens: [],
          players: []
        }));

        for (const e of state.entities) {
          if (e.type === "citizen") {
            tilePop[e.tileIndex].citizens.push(e);
          } else if (e.type === "player") {
            tilePop[e.tileIndex].players.push(e);
          }
        }

        let citizenRate = BASE_INFECTION_RATE;
        let playerRate = PLAYER_BASE_RATE;

        let newInf = 0;

        for (let t = 0; t < NUM_TILES; t++) {
          const tile = tilePop[t];
          const citizens = tile.citizens;
          const players = tile.players;

          const infectedPlayers = players.filter(p => p.infected);
          const startInfCitizens = citizens.filter(
            c => c.infected && !c.recovered
          );

          // 건강한 시민 = 감염 X, 회복 X, 접종 X
          let healthy = citizens.filter(
            c => !c.infected && !c.recovered && !c.vaccinated
          );

          // 감염된 플레이어 → 시민 1명 감염 시도
          for (const p of infectedPlayers) {
            if (healthy.length === 0) break;
            
            const idx = randInt(healthy.length);
            const target = healthy[idx];

            if (Math.random() < playerRate) {
              target.infected = true;
              target.infectedTurn = GameState.currentTurn;
              newInf++;
            }
            healthy.splice(idx, 1);
          }

          // 감염된 시민 → 최대 2명 감염 시도
          for (const src of startInfCitizens) {
            for (let k = 0; k < 2; k++) {
              if (healthy.length === 0) break;
              
              const idx = randInt(healthy.length);
              const target = healthy[idx];

              if (Math.random() < citizenRate) {
                target.infected = true;
                target.infectedTurn = GameState.currentTurn;
                newInf++;
              }
              healthy.splice(idx, 1);
            }
          }
        }
        
        return newInf;
      }
      
      // 8-1. 백신 접종 단계 (2번째 게임 전용)
      //  - 백신을 영구 획득한 플레이어(hasVaccine=true)는
      //    자신이 위치한 타일 + 인접 타일 중 랜덤 2칸의
      //    모든 시민에게 접종을 시도한다.
      function stepVaccination() {
        const state = GameState;
        const { NUM_TILES } = GameConfig;

        // 타일별 시민 목록 모으기
        const tileCitizens = [...Array(NUM_TILES)].map(() => []);

        for (const e of state.entities) {
          if (e.type === "citizen") {
            tileCitizens[e.tileIndex].push(e);
          }
        }

        // 각 플레이어에 대해 접종 처리
        for (const p of state.entities) {
          if (p.type !== "player") continue;
          if (!p.hasVaccine) continue; // ★ 연구소에서 백신을 얻지 않은 플레이어는 패스

          // 1) 영향을 주는 타일 집합: 본인 타일 + 인접 타일 중 랜덤 2칸
          const affectedTiles = new Set();
          affectedTiles.add(p.tileIndex);

          const neighbors = getNeighborIndices(p.tileIndex);

          if (p.enhancedVaccine) {
            // ★ 업그레이드 상태: 주변 1칸 전체에 접종
            neighbors.forEach(n => affectedTiles.add(n));
          } else {
            // 기본 상태: 주변 타일 중 랜덤 2칸만 추가
            if (neighbors.length > 0) {
              const shuffled = neighbors.slice().sort(() => Math.random() - 0.5);
              const pickCount = Math.min(2, shuffled.length);
              for (let i = 0; i < pickCount; i++) {
                affectedTiles.add(shuffled[i]);
              }
            }
          }

          // 2) 해당 타일들에 있는 시민 전체 접종
          let vaccinatedCount = 0;

          affectedTiles.forEach(tileIdx => {
            const citizensHere = tileCitizens[tileIdx];
            if (!citizensHere || citizensHere.length === 0) return;

            for (const c of citizensHere) {
              // 아직 감염되지 않았고, 회복도 아니고, 이미 접종된 적도 없는 시민만 대상
              if (!c.infected && !c.recovered && !c.vaccinated) {
                c.vaccinated = true;
                vaccinatedCount++;
              }
            }
          });

          if (vaccinatedCount > 0) {
            addLog(
              `플레이어 ${p.id}가 인접 지역을 포함해 시민 ${vaccinatedCount}명에게 백신을 접종했습니다.`
            );
          }
        }
      }

      function stepRecovery() {
        const RECOVERY_TURNS = GameConfig.RECOVERY_TURNS;

        for (const e of GameState.entities) {
          if (e.type !== "citizen") continue;
          if (!e.infected) continue;
          if (e.recovered) continue;

          if (
            e.infectedTurn !== null &&
            GameState.currentTurn - e.infectedTurn >= RECOVERY_TURNS
          ) {
            e.infected = false;
            e.recovered = true;
            e.infectedTurn = null;
          }
        }
      }

      function computeTileStats() {
        const { NUM_TILES } = GameConfig;
        const state = GameState;

        const tiles = [...Array(NUM_TILES)].map(() => ({
          total: 0,
          infected: 0,
          vaccinatedCitizens: 0, // ★ 백신 맞은 시민 수
          hasChest: false
        }));

        for (const e of state.entities) {
          const t = tiles[e.tileIndex];
          t.total++;
          if (e.infected) t.infected++;

          // ★ 시민이면서, 백신 접종 상태면 카운트
          if (e.type === "citizen" && e.vaccinated) {
            t.vaccinatedCitizens++;
          }
        }

        state.activeChestTiles.forEach(idx => {
          if (tiles[idx]) tiles[idx].hasChest = true;
        });

        return tiles;
      }

      // =========================
      // 9. 렌더링
      // =========================
      // ★★★ 여기서부터 renderTiles 전체 교체 ★★★
      function renderTiles() {
        const { NUM_TILES } = GameConfig;
        const state = GameState;

        // 스캔 하이라이트 시간 만료 체크
        if (
          state.scanHighlightTileIndex !== null &&
          state.scanHighlightUntil > 0 &&
          Date.now() > state.scanHighlightUntil
        ) {
          state.scanHighlightTileIndex = null;
          state.scanHighlightUntil = 0;
        }

        let tiles;
        let tileEntities;

        if (NetState.roomId && !NetState.isTeacher && state.remoteTileStats) {
          tiles = state.remoteTileStats;

          tileEntities = [...Array(NUM_TILES)].map(() => ({
            players: [],
            citizens: []
          }));

          for (const e of state.entities) {
            if (e.type === "player") {
              tileEntities[e.tileIndex].players.push(e);
            }
          }
        } else {
          tiles = [...Array(NUM_TILES)].map(() => ({
            total: 0,
            infected: 0,
            players: 0,
            vaccinatedCitizens: 0,
            hasChest: false
          }));

          tileEntities = [...Array(NUM_TILES)].map(() => ({
            players: [],
            citizens: []
          }));

          for (const e of state.entities) {
            const t = tiles[e.tileIndex];
            t.total++;
            if (e.infected) t.infected++;

            if (e.type === "player") {
              t.players++;
              tileEntities[e.tileIndex].players.push(e);
            } else {
              tileEntities[e.tileIndex].citizens.push(e);

              if (e.vaccinated) {
                t.vaccinatedCitizens++;
              }
            }
          }

          state.activeChestTiles.forEach(idx => {
            if (tiles[idx]) tiles[idx].hasChest = true;
          });
        }

        // 학생 클라이언트에서만 시야 제한 적용
        let visibleRegionForStudent = null;
        if (NetState.roomId && !NetState.isTeacher) {
          const myPlayer = GameState.entities.find(
            e => e.type === "player" && e.id === NetState.playerId
          );
          if (myPlayer) {
            const origin = myPlayer.tileIndex;

            // ★ 시야: 내 말 기준 "최단 거리 3칸 이내" 타일까지 보이게 (BFS)
            const maxDepth = 3;
            const visited = new Set();
            const s = new Set();

            visited.add(origin);
            s.add(origin);

            const queue = [{ idx: origin, dist: 0 }];

            while (queue.length > 0) {
              const { idx, dist } = queue.shift();
              if (dist >= maxDepth) continue;

              const neighbors = getNeighborIndices(idx);
              for (const nb of neighbors) {
                if (!visited.has(nb)) {
                  visited.add(nb);
                  s.add(nb);
                  queue.push({ idx: nb, dist: dist + 1 });
                }
              }
            }

            visibleRegionForStudent = s;
          }
        }

        // === 연구소 근처 힌트용: 현재 포커스 플레이어 & 연구소까지 최소 거리 계산 ===
        let focusPlayer = null;

        // 1) 멀티 학생 모드: 내 플레이어 기준
        if (NetState.roomId && NetState.playerId) {
          focusPlayer = GameState.entities.find(
            e => e.type === "player" && e.id === NetState.playerId
          );
        } else {
          // 2) 싱글플레이나 교사 단독 플레이일 때: 첫 번째 플레이어 기준
          focusPlayer = GameState.entities.find(e => e.type === "player");
        }

        let minDistToLabForFocus = Infinity;

        if (focusPlayer && GameState.activeChestTiles && GameState.activeChestTiles.size > 0) {
          for (const labIdx of GameState.activeChestTiles) {
            const d = getTileDistance(focusPlayer.tileIndex, labIdx, 20);
            if (d < minDistToLabForFocus) {
              minDistToLabForFocus = d;
            }
          }
        }

        // 직전 거리 갱신 (다음 프레임/턴에서 비교용)
        GameState.prevNearLabDistance = minDistToLabForFocus;

        
        for (let i = 0; i < NUM_TILES; i++) {
          const t = tiles[i];
          const el = state.tileElements[i];
          if (!el) continue;

          // 학생이 이 타일을 볼 수 있는지
          let canSeeThisTile = true;
          if (NetState.roomId && !NetState.isTeacher && visibleRegionForStudent) {
            canSeeThisTile = visibleRegionForStudent.has(i);
          }

          el.pop.textContent = t.total;

          const isLabTile = !!t.hasChest;
          const isScanHighlighted = state.scanHighlightTileIndex === i;
          let showLab = false;

          if (state.vaccineFeatureEnabled && isLabTile) {
            if (!NetState.roomId || NetState.isTeacher) {
              showLab = true;
            } else if (
              visibleRegionForStudent &&
              visibleRegionForStudent.has(i)
            ) {
              showLab = true;
            }
          }

          // 스캔 하이라이트 타일은 시야 밖이어도 강제로 보이게
          if (isScanHighlighted) {
            showLab = true;
          }

          // stroke 초기화
          el.path.classList.remove("scan-highlight");

          // 학생 모드에서 시야 밖 타일인지 여부
          const isHiddenFog =
            NetState.roomId &&
            !NetState.isTeacher &&
            visibleRegionForStudent &&
            !canSeeThisTile &&
            !isScanHighlighted;

          const fogEl = el.fog;
          const fogPath = el.fogPath;

          // 1) 시야와 관계없이 감염/백신 색 먼저 칠함
          if (showLab) {
            el.path.style.fill = "rgba(200, 220, 255, 0.9)";
            if (isScanHighlighted) {
              el.path.classList.add("scan-highlight");
            }
          } else {
            const totalPop = t.total || 0;
            const infectedRatio =
              totalPop > 0 ? (t.infected || 0) / totalPop : 0;
            const vaccinatedRatio =
              totalPop > 0 ? (t.vaccinatedCitizens || 0) / totalPop : 0;

            let r, g, b;

            if (totalPop === 0) {
              r = g = b = 250;
            } else {
              r = 255;
              g = Math.round(255 * (1 - infectedRatio));
              b = Math.round(255 * (1 - infectedRatio));

              r -= Math.round(155 * vaccinatedRatio);
              b -= Math.round(155 * vaccinatedRatio);

              r = Math.max(0, Math.min(255, r));
              g = Math.max(0, Math.min(255, g));
              b = Math.max(0, Math.min(255, b));
            }

            el.path.style.fill = `rgb(${r}, ${g}, ${b})`;
          }

          // 2) 시야 밖이면 타일 전체 fogPath + 중앙에 ? 표시
          if (isHiddenFog) {
            if (fogEl) fogEl.style.display = "flex";
            if (fogPath) fogPath.style.display = "block";
          } else {
            if (fogEl) fogEl.style.display = "none";
            if (fogPath) fogPath.style.display = "none";
          }

          const pieceContainer = el.pieces;
          pieceContainer.innerHTML = "";

          // 말(플레이어)은 시야 안 타일에서만 보이게
          if (canSeeThisTile) {
            const playersHere = tileEntities[i].players;
            playersHere.forEach(p => {
              const d = document.createElement("div");
              d.className = "piece player" + (p.infected ? " infected" : "");

              if (NetState.playerId && p.id === NetState.playerId) {
                d.classList.add("me");
              }
              pieceContainer.appendChild(d);
            });
          }
        }
      }
      
      function updateInfectedHistory() {
        const hist = GameState.historyCumulativeInfected;
        if (hist.length === 0) {
          UI.infectedHistoryBox.innerHTML =
            "<div><b>턴별 누적 감염 인구 (기록용)</b></div><div>아직 데이터가 없습니다.</div>";
          return;
        }
        let html = "<div><b>턴별 누적 감염 인구 (기록용)</b></div>";
        for (const h of hist) {
          html += `<div>T${h.turn}: ${h.infected}명</div>`;
        }
        UI.infectedHistoryBox.innerHTML = html;
      }

      function updateNewInfectedHistory() {
        const hist = GameState.historyNewInfected;
        if (hist.length === 0) {
          UI.newInfectedHistoryBox.innerHTML =
            "<div><b>턴별 신규 감염자 수 (기록용)</b></div><div>아직 데이터가 없습니다.</div>";
          return;
        }
        let html = "<div><b>턴별 신규 감염자 수 (기록용)</b></div>";
        for (const h of hist) {
          html += `<div>T${h.turn}: ${h.newInfected}명</div>`;
        }
        UI.newInfectedHistoryBox.innerHTML = html;
      }

      function renderStats() {
        const state = GameState;
        const total = GameConfig.NUM_CITIZENS + GameConfig.NUM_PLAYERS;

        let inf;

        if (NetState.roomId && !NetState.isTeacher && state.remoteInfectedTotal != null) {
          inf = state.remoteInfectedTotal;
        } else {
          inf = computeInfectedCount();
        }

        UI.statInfected.textContent = inf;
        UI.statRatio.textContent = Math.round((inf / total) * 100) + "%";
        UI.statTurn.textContent = state.currentTurn;

        if (!state.vaccineFeatureEnabled) {
          UI.statOpenedChests.textContent = "-";
          UI.statVaccineStatus.textContent = "비활성화";
        } else {
          UI.statOpenedChests.textContent = `${state.openedChestCount}%`;
          UI.statVaccineStatus.textContent = state.vaccineActive
            ? "완성"
            : "개발 중";
        }

        if (!(NetState.roomId && !NetState.isTeacher)) {
          if (state.lastRecordedTurn !== state.currentTurn) {
            state.historyCumulativeInfected.push({
              turn: state.currentTurn,
              infected: state.cumulativeInfectedTotal 
            });
            state.lastRecordedTurn = state.currentTurn;
            updateInfectedHistory();
          }
        }
      }

      function renderAll() {
        renderTiles();
        renderStats();
      }

      // ★★★ 여기서부터 스캔/퀴즈 시스템 추가 ★★★

      // 현재 플레이어 기준 시야 3칸 이내 타일 집합 계산 (BFS)
      function getVisibleRegionFrom(originIndex, maxDepth = 3) {
        const visited = new Set();
        const s = new Set();
        visited.add(originIndex);
        s.add(originIndex);

        const queue = [{ idx: originIndex, dist: 0 }];

        while (queue.length > 0) {
          const { idx, dist } = queue.shift();
          if (dist >= maxDepth) continue;

          const neighbors = getNeighborIndices(idx);
          for (const nb of neighbors) {
            if (!visited.has(nb)) {
              visited.add(nb);
              s.add(nb);
              queue.push({ idx: nb, dist: dist + 1 });
            }
          }
        }

        return s;
      }

      // 현재(학생) 플레이어 기준, "시야 밖에 있는" 연구소 중 가장 가까운 곳 찾기
      function findClosestHiddenLabForCurrentPlayer() {
        const labs = Array.from(GameState.activeChestTiles || []);
        if (!labs.length) return null;

        let myPlayer = null;
        if (NetState.playerId) {
          myPlayer = GameState.entities.find(
            e => e.type === "player" && e.id === NetState.playerId
          );
        } else {
          // 싱글플레이 또는 방이 없을 때는 첫 번째 플레이어 기준
          myPlayer = GameState.entities.find(e => e.type === "player");
        }
        if (!myPlayer) return null;

        const origin = myPlayer.tileIndex;
        const visible = getVisibleRegionFrom(origin, 3);

        const hiddenLabs = labs.filter(idx => !visible.has(idx));
        if (!hiddenLabs.length) {
          return null;
        }

        let bestTile = null;
        let bestDist = Infinity;

        for (const tile of hiddenLabs) {
          const d = getTileDistance(origin, tile, 30);
          if (d < bestDist) {
            bestDist = d;
            bestTile = tile;
          }
        }

        if (bestTile === null || bestDist === Infinity) return null;

        return { tileIndex: bestTile, distance: bestDist };
      }

      // 문자열 정규화: 공백 제거 + 소문자 통일
      function normalizeAnswerText(str) {
        if (!str) return "";
        return str
          .toString()
          .trim()
          .toLowerCase()
          .replace(/\s+/g, "");  // 모든 공백 제거
      }

      // 주관식 정답 제출 처리
      function submitShortAnswer(quiz, userInput) {
        if (GameState.hasAnsweredQuiz) {
          closeQuizOverlay();
          return;
        }

        const userNorm = normalizeAnswerText(userInput);
        const answerNorm = normalizeAnswerText(quiz.answerText);

        const isCorrect = (userNorm === answerNorm);
        handleQuizAnswer(isCorrect);
      }

      // 퀴즈 오버레이 열기 (주관식 + 객관식 지원)
      function openQuizOverlay(quiz) {
        if (!UI.quizOverlay) return;

        // 문제 텍스트 넣기
        UI.quizQuestionText.textContent = quiz.question;
        UI.quizChoices.innerHTML = "";

        // ① 주관식 (type: "short")
        if (quiz.type === "short") {
          const input = document.createElement("input");
          input.type = "text";
          input.placeholder = "정답을 입력하세요";
          input.style.width = "100%";
          input.style.padding = "8px 10px";
          input.style.borderRadius = "999px";
          input.style.border = "1px solid #ccc";

          const submitBtn = document.createElement("button");
          submitBtn.className = "btn";
          submitBtn.textContent = "정답 제출";
          submitBtn.style.marginTop = "8px";

          input.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
              e.preventDefault();
              submitShortAnswer(quiz, input.value);
            }
          });

          submitBtn.addEventListener("click", () => {
            submitShortAnswer(quiz, input.value);
          });

          UI.quizChoices.appendChild(input);
          UI.quizChoices.appendChild(submitBtn);
        }
        // ② 객관식 (choices + answerIndex가 있는 경우)
        else if (Array.isArray(quiz.choices) && typeof quiz.answerIndex === "number") {
          quiz.choices.forEach((choiceText, idx) => {
            const btn = document.createElement("button");
            btn.className = "quiz-choice-btn";
            btn.textContent = choiceText;
            btn.addEventListener("click", () => {
              handleQuizAnswer(idx === quiz.answerIndex);
            });
            UI.quizChoices.appendChild(btn);
          });
        }

        UI.quizOverlay.classList.add("active");
        UI.quizOverlay.style.display = "flex";
      }

      // 퀴즈 오버레이 닫기
      function closeQuizOverlay() {
        if (!UI.quizOverlay) return;
        UI.quizOverlay.classList.remove("active");
        UI.quizOverlay.style.display = "none";
      }

      // 싱글플레이/로컬에서 연구소 퀴즈 시작
      function startLabQuizForPlayerLocal(player, delta) {
        const bank = GameState.quizBank || [];
        if (!bank.length) {
          // 퀴즈가 없으면 바로 적용
          GameState.openedChestCount = Math.max(
            0,
            Math.min(100, GameState.openedChestCount + delta)
          );
          if (!player.visitedLabs) player.visitedLabs = new Set();
          player.visitedLabs.add(player.tileIndex);
          addLog(
            `플레이어 ${player.id}가 연구소를 방문해 백신 개발률이 ${delta > 0 ? "+" + delta : delta}% 변화했습니다. (현재 ${GameState.openedChestCount}%)`
          );
          if (GameState.openedChestCount >= 100 && !GameState.vaccineActive) {
            GameState.vaccineActive = true;
            addLog("백신이 완성되었습니다! 그런데.. 백신 접종은 어떻게 하죠?");
          }
          return;
        }

        // ★ 이미 정답을 맞힌 문제는 제외하고, 남는 게 없으면 전체 풀에서 선택
        const unsolved = bank.filter(q => !GameState.quizSolvedCorrectly.has(q.id));
        const quizPool = unsolved.length > 0 ? unsolved : bank;
        const quiz = quizPool[Math.floor(Math.random() * quizPool.length)];

        GameState.activeQuizId = quiz.id;
        GameState.hasAnsweredQuiz = false;
        GameState.quizContext = "lab";
        GameState.labQuizPendingDelta = delta;
        GameState.labQuizPendingPlayerId = player.id;
        GameState.labQuizPendingTileIndex = player.tileIndex;

        addLog(
          `플레이어 ${player.id}가 연구소에 도착했습니다. 문제를 맞히면 백신 개발률이 변화합니다.`
        );
        openQuizOverlay(quiz);
      }

      // 싱글플레이/로컬에서 2번째 게임(백신 획득용) 연구소 퀴즈 시작
      function startVaccineLabQuizForPlayerLocal(player, stage) {
        const bank = GameState.quizBank || [];
        if (!bank.length) {
          // 퀴즈가 없으면 예전 로직 그대로 즉시 처리
          applyVaccinationRewardImmediate(player, stage);
          return;
        }

        // ★ 이미 정답을 맞힌 문제는 제외하고, 남는 게 없으면 전체 풀에서 선택
        const unsolved = bank.filter(q => !GameState.quizSolvedCorrectly.has(q.id));
        const quizPool = unsolved.length > 0 ? unsolved : bank;
        const quiz = quizPool[Math.floor(Math.random() * quizPool.length)];

        GameState.activeQuizId = quiz.id;
        GameState.hasAnsweredQuiz = false;
        GameState.quizContext = "lab";
        GameState.labQuizPendingPlayerId = player.id;
        GameState.labQuizPendingTileIndex = player.tileIndex;
        GameState.labQuizPendingVaccinationStage = stage;

        if (stage === 2) {
          addLog(
            `플레이어 ${player.id}가 두 번째 연구소에 도착했습니다. 기록을 해석하면 백신 샘플을 얻을 수 있을지도 모릅니다.`
          );
        } else if (stage === 3) {
          addLog(
            `플레이어 ${player.id}가 세 번째 연구소에 도착했습니다. 남은 기록을 해석하면 강력한 백신 시스템을 완성할 수 있습니다.`
          );
        }

        openQuizOverlay(quiz);
      }

      // 퀴즈 없이 바로 기존 2편 로직을 적용해야 할 때 쓰는 도우미
      function applyVaccinationRewardImmediate(player, stage) {
        if (!player.visitedLabs) {
          player.visitedLabs = new Set();
        }

        const visitedCount = player.visitedLabs.size;

        // stage와 visitedCount가 다를 수도 있으니, 둘 중 큰 값 기준으로 처리
        const effectiveStage = Math.max(stage || 0, visitedCount || 0);

        // 1번째 연구소: 스토리만
        if (effectiveStage === 1) {
          addLog(
            `플레이어 ${player.id}가 첫 번째 연구소에 도착했습니다. 오래된 기록 속에서 백신의 단서를 찾고 있습니다.`
          );
          return;
        }

        // 2번째 연구소: 50% 확률로 백신 획득 시도
        if (effectiveStage === 2 && !player.hasVaccine) {
          if (Math.random() < 0.5) {
            player.hasVaccine = true;
            player.enhancedVaccine = false;
            addLog(
              `플레이어 ${player.id}가 두 번째 연구소에서 우연히 완성된 백신 샘플을 발견했습니다! 이제 이동할 때마다 주변 시민들에게 접종할 수 있습니다.`
            );
          } else {
            addLog(
              `플레이어 ${player.id}가 두 번째 연구소를 샅샅이 뒤졌지만, 백신 개발 기록은 불완전합니다. (다른 연구소를 더 찾아봐야 할 것 같습니다.)`
            );
          }
          return;
        }

        // 3번째 연구소:
        //  - 아직 백신이 없다면 100%로 획득 + 업그레이드
        //  - 이미 백신이 있다면 범위/이동력 업그레이드만 부여
        if (effectiveStage === 3) {
          if (!player.hasVaccine) {
            player.hasVaccine = true;
            player.enhancedVaccine = true;
            addLog(
              `플레이어 ${player.id}가 세 번째 연구소에 도착해 백신의 마지막 조각을 완성했습니다! 이제 더 넓은 범위에 백신을 접종하고, 두 칸까지 이동할 수 있습니다.`
            );
          } else if (!player.enhancedVaccine) {
            player.enhancedVaccine = true;
            addLog(
              `플레이어 ${player.id}가 세 번째 연구소에 도착해 백신 시스템을 업그레이드했습니다! 이제 주변 1칸 전체에 접종하고, 두 칸까지 이동할 수 있습니다.`
            );
          } else {
            addLog(
              `플레이어 ${player.id}는 이미 강화된 백신을 보유하고 있어, 이번 연구소에서는 얻을 새로운 것이 없었습니다.`
            );
          }
          return;
        }
      }

      // 연구소 퀴즈 결과 적용
      //  - 1편(DEVELOPMENT): 백신 개발률(openedChestCount) 증감
      //  - 2편(VACCINATION): 백신 획득/업그레이드 처리
      function applyLabQuizResult(isCorrect) {
        const state = GameState;

        // 공통으로 쓰는 식별자들
        const playerId = state.labQuizPendingPlayerId;
        const tileIndex = state.labQuizPendingTileIndex;
        const stage = state.labQuizPendingVaccinationStage || 0;

        let player = null;
        if (playerId) {
          player = state.entities.find(
            e => e.type === "player" && e.id === playerId
          );
        }

        // 서버에 기록할 보상 타입
        //  - "none"               : 보상 없음
        //  - "devProgress"        : 1편 개발률 변화
        //  - "vaccineSuccess"     : 2편, 백신 새로 획득
        //  - "vaccineFail"        : 2편, 기록 해석은 성공했지만 백신은 못 얻음
        //  - "vaccineAndUpgrade"  : 2편, 백신+업그레이드 동시에
        //  - "upgradeOnly"        : 2편, 기존 백신에 업그레이드만
        //  - "alreadyMax"         : 2편, 이미 최대 상태
        let rewardType = "none";

        // 대상을 찾지 못했으면 초기화만 하고 종료
        if (!player) {
          state.quizContext = null;
          state.labQuizPendingDelta = 0;
          state.labQuizPendingPlayerId = null;
          state.labQuizPendingTileIndex = null;
          state.labQuizPendingVaccinationStage = 0;
          return rewardType;
        }

        if (!player.visitedLabs) {
          player.visitedLabs = new Set();
        }
        if (tileIndex != null) {
          player.visitedLabs.add(tileIndex);
        }

        // ──────────────────────────────
        // 1편: 백신 개발 모드
        // ──────────────────────────────
        if (state.gameMode === GameModes.DEVELOPMENT) {
          const delta = state.labQuizPendingDelta || 0;

          if (isCorrect && delta) {
            // 개발률 반영
            state.openedChestCount = Math.max(
              0,
              Math.min(100, state.openedChestCount + delta)
            );

            rewardType = "devProgress";

            addLog(
              `플레이어 ${player.id}가 연구소 문제를 맞혀 백신 개발률이 ${delta > 0 ? "+" + delta : delta}% 변화했습니다. (현재 ${state.openedChestCount}%)`
            );

            if (state.openedChestCount >= 100 && !state.vaccineActive) {
              state.vaccineActive = true;
              addLog("백신이 완성되었습니다! 그런데.. 백신 접종은 어떻게 하죠?");
            }
          } else if (!isCorrect) {
            addLog(
              `플레이어 ${player.id}가 연구소 문제를 맞히지 못해 백신 개발률은 변하지 않습니다.`
            );
          }

          state.quizContext = null;
          state.labQuizPendingDelta = 0;
          state.labQuizPendingPlayerId = null;
          state.labQuizPendingTileIndex = null;
          state.labQuizPendingVaccinationStage = 0;

          return rewardType;
        }

        // ──────────────────────────────
        // 2편: 백신 접종 모드
        // ──────────────────────────────
        if (state.gameMode === GameModes.VACCINATION) {
          // 틀렸으면 이번 연구소에서는 아무 효과 없음
          if (!isCorrect) {
            addLog(
              `플레이어 ${player.id}가 연구소 문제를 맞히지 못해, 이번 연구소에서는 특별한 백신을 얻지 못했습니다.`
            );

            state.quizContext = null;
            state.labQuizPendingDelta = 0;
            state.labQuizPendingPlayerId = null;
            state.labQuizPendingTileIndex = null;
            state.labQuizPendingVaccinationStage = 0;
            return rewardType; // "none"
          }

          // 정답일 때만, 기존 2편 로직을 stage에 맞춰 적용
          if (stage === 2 && !player.hasVaccine) {
            // 2번째 연구소: 50% 확률로 백신 획득 시도
            if (Math.random() < 0.5) {
              player.hasVaccine = true;
              player.enhancedVaccine = false;
              rewardType = "vaccineSuccess";

              addLog(
                `플레이어 ${player.id}가 두 번째 연구소 기록을 성공적으로 해석해, 오래된 백신 샘플을 손에 넣었습니다! 이제 이동할 때마다 주변 시민들에게 접종할 수 있습니다.`
              );
            } else {
              rewardType = "vaccineFail";

              addLog(
                `플레이어 ${player.id}가 두 번째 연구소 기록을 해석했지만, 결정적인 백신 정보는 찾지 못했습니다.`
              );
            }
          } else if (stage === 3) {
            // 3번째 연구소:
            //  - 아직 백신이 없다면 100%로 획득 + 업그레이드
            //  - 이미 백신이 있다면 범위/이동력 업그레이드만 부여
            if (!player.hasVaccine) {
              player.hasVaccine = true;
              player.enhancedVaccine = true;
              rewardType = "vaccineAndUpgrade";

              addLog(
                `플레이어 ${player.id}가 세 번째 연구소 기록을 해석해, 백신의 마지막 조각을 완성했습니다! 이제 더 넓은 범위에 접종하고, 두 칸까지 이동할 수 있습니다.`
              );
            } else if (!player.enhancedVaccine) {
              player.enhancedVaccine = true;
              rewardType = "upgradeOnly";

              addLog(
                `플레이어 ${player.id}가 세 번째 연구소 기록을 해석해, 기존 백신 시스템을 업그레이드했습니다! 이제 주변 1칸 전체에 접종하고, 두 칸까지 이동할 수 있습니다.`
              );
            } else {
              rewardType = "alreadyMax";

              addLog(
                `플레이어 ${player.id}는 이미 강화된 백신을 보유하고 있어, 이번 연구소에서는 추가 업그레이드가 필요하지 않았습니다.`
              );
            }
          } else {
            // 혹시 stage 정보가 없으면, 최소한의 안내만
            rewardType = "none";

            addLog(
              `플레이어 ${player.id}가 연구소 기록 해석에 성공했습니다. (추가 효과는 설정되지 않았습니다.)`
            );
          }

          state.quizContext = null;
          state.labQuizPendingDelta = 0;
          state.labQuizPendingPlayerId = null;
          state.labQuizPendingTileIndex = null;
          state.labQuizPendingVaccinationStage = 0;
          return rewardType;
        }

        // 혹시 모를 기타 상황
        state.quizContext = null;
        state.labQuizPendingDelta = 0;
        state.labQuizPendingPlayerId = null;
        state.labQuizPendingTileIndex = null;
        state.labQuizPendingVaccinationStage = 0;
        return rewardType;
      }


      // 정답을 맞춘 학생에게만 "시야 밖 연구소" 하이라이트 적용
      function applyScanHighlightForCurrentPlayer() {
        const result = findClosestHiddenLabForCurrentPlayer();
        if (!result) {
          addLog("스캔 결과: 현재 시야 밖에 따로 숨은 연구소가 없거나 찾지 못했습니다.");
          return;
        }

        GameState.scanHighlightTileIndex = result.tileIndex;
        GameState.scanHighlightUntil = Date.now() + 10000; // 10초간 표시

        renderAll();
      }

      // 교사가 스캔(레이더) 버튼을 눌렀을 때 호출
      async function triggerScanForTeacher() {
        if (!NetState.isTeacher) {
          alert("스캔 기능은 교사만 사용할 수 있습니다.");
          return;
        }

        const bank = GameState.quizBank || [];
        if (!bank.length) {
          alert("퀴즈가 아직 준비되지 않았습니다. GameState.quizBank를 채워 넣으세요.");
          return;
        }

        // ★ 이미 정답을 맞힌 문제는 가능하면 제외한 뒤, 남는 문제에서 랜덤 선택
        const unsolved = bank.filter(q => !GameState.quizSolvedCorrectly.has(q.id));
        const quizPool = unsolved.length > 0 ? unsolved : bank;
        const quiz = quizPool[Math.floor(Math.random() * quizPool.length)];

        GameState.activeQuizId = quiz.id;
        GameState.hasAnsweredQuiz = false;
        GameState.quizContext = "scan";

        // 1) 싱글플레이 또는 방이 없는 경우: 내 화면에만 퀴즈 표시
        if (!NetState.roomId || !NetState.scanRef) {
          openQuizOverlay(quiz);
          return;
        }

        // 2) 멀티플레이: RTDB에 퀴즈 ID를 기록 → 학생들이 subscribeScan으로 감지
        await NetState.scanRef.set({
          quizId: quiz.id,
          startedAt: Date.now()
        });

        // 교사 본인은 굳이 퀴즈를 풀 필요가 없으므로 표시하지 않음
        addLog("스캔 퀴즈가 모든 학생에게 전송되었습니다.");
      }

      // RTDB의 scan 노드를 구독하여, 새 퀴즈가 올라오면 학생 쪽에 UI 표시
      function subscribeScan() {
        if (!NetState.scanRef) return;

        NetState.scanRef.on("value", snapshot => {
          const data = snapshot.val();
          if (!data) return;

          // 교사 클라이언트는 퀴즈를 표시하지 않음
          if (NetState.isTeacher) return;

          const quizId = data.quizId;
          const startedAt = data.startedAt || 0;
          if (!quizId) return;

          // 이미 처리한(또는 그 이전) 스캔 이벤트면 무시
          if (startedAt <= GameState.lastScanStartedAt) {
            return;
          }

          // 이 시점부터는 "새로운 스캔 이벤트"로 인정
          GameState.lastScanStartedAt = startedAt;

          // 이 학생이 이미 정답을 맞춘 퀴즈라면, 더 이상 출제하지 않음
          if (GameState.quizSolvedCorrectly.has(quizId)) {
            addLog("이미 정답을 맞춘 스캔 문제는 이 학생에게 다시 출제되지 않습니다.");
            return;
          }

          const bank = GameState.quizBank || [];
          const quiz = bank.find(q => q.id === quizId);
          if (!quiz) {
            console.warn("퀴즈 ID를 찾을 수 없습니다:", quizId);
            return;
          }

          GameState.activeQuizId = quiz.id;
          GameState.hasAnsweredQuiz = false;
          GameState.quizContext = "scan";

          openQuizOverlay(quiz);
        });
      }

      // RTDB의 labQuiz 노드를 구독하여,
      //  - 학생: 내 퀴즈만 화면에 표시
      //  - 교사: 결과만 받아서 1편/2편 효과 적용
      function subscribeLabQuiz() {
        if (!NetState.labQuizRef) return;

        NetState.labQuizRef.on("value", snapshot => {
          const data = snapshot.val();
          if (!data) return;

          // ── 학생 클라이언트: 내 플레이어를 대상으로 하는 연구소 퀴즈인지 확인 ──
          if (!NetState.isTeacher) {
            const myId = NetState.playerId;
            if (!myId) return;

            // 1) 새 퀴즈 시작 감지 (기존 코드 유지)
            if (data.targetPlayerId === myId && data.quizId) {
              const startedAt = data.startedAt || 0;
              if (startedAt > GameState.lastLabQuizStartedAt) {
                GameState.lastLabQuizStartedAt = startedAt;

                const bank = GameState.quizBank || [];
                let quiz = bank.find(q => q.id === data.quizId);
                if (!quiz && bank.length > 0) {
                  quiz = bank[0];
                }
                if (quiz) {
                  // ★ 이미 정답을 맞춘 문제라면, 문제창을 띄우지 않고 자동으로 정답 처리
                  if (GameState.quizSolvedCorrectly.has(quiz.id)) {
                    addLog(
                      "이전에 정답을 맞힌 연구소 문제이므로, 다시 풀지 않고 자동으로 정답 처리합니다."
                    );
                    // 서버(교사) 쪽에 정답 결과만 바로 전송
                    NetState.labQuizRef.child("result").set({
                      correct: true,
                      answeredBy: myId,
                      answeredAt: Date.now()
                    });
                    return;
                  }

                  GameState.activeQuizId = quiz.id;
                  GameState.hasAnsweredQuiz = false;
                  GameState.quizContext = "lab";

                  GameState.labQuizPendingDelta = data.delta || 0;
                  GameState.labQuizPendingVaccinationStage = data.stage || 0;
                  GameState.labQuizPendingPlayerId = myId;

                  const localPlayer = GameState.entities.find(
                    e => e.type === "player" && e.id === myId
                  );
                  GameState.labQuizPendingTileIndex = localPlayer ? localPlayer.tileIndex : null;

                  openQuizOverlay(quiz);
                }
              }
            }

            // 2) 교사(서버)가 결정한 최종 결과 감지 → 학생 로그로 출력
            const res = data.result;
            if (!res) return;

            const processedAt = res.processedAt || 0;
            if (processedAt <= (GameState.lastLabServerResultAt || 0)) {
              return;
            }
            GameState.lastLabServerResultAt = processedAt;

            if (res.playerId !== myId) {
              return; // 다른 학생 결과면 무시
            }

            const reward = res.reward || "none";
            const mode = res.mode || GameState.gameMode;
            const stage = res.stage || 0;
            const correct = !!res.correct;

            if (mode === GameModes.VACCINATION && stage === 2) {
              // 2번째 연구소 결과
              if (!correct) {
                // 이미 handleQuizAnswer 에서 "암호가 틀린 탓일까요..." 로그를 찍으므로
                // 여기서는 굳이 추가 로그가 없어도 됨. 필요하면 한 줄 더 찍어도 됨.
                return;
              }

              const me = GameState.entities.find(
                e => e.type === "player" && e.id === myId
              );

              if (reward === "vaccineSuccess") {
                // ★ 로컬 플레이어에도 백신 보유 상태 반영
                if (me) {
                  me.hasVaccine = true;
                  if (!me.enhancedVaccine) {
                    me.enhancedVaccine = false;
                  }
                }

                addLog(
                  "적은 양이지만, 실제로 사용할 수 있는 백신 샘플이 들어있었습니다. 이제 이동할 때마다 주변 시민에게 접종할 수 있습니다."
                );
              } else if (reward === "vaccineFail") {
                addLog(
                  "금고의 내부에는 보고서 몇 장이 존재할 뿐이었습니다. 다른 연구소를 찾아야겠네요..."
                );
              }
            } else if (mode === GameModes.VACCINATION && stage === 3) {
              // 3번째 연구소 결과 (원하면 여기서도 세분화 가능)
              if (!correct) {
                return;
              }

              const me = GameState.entities.find(
                e => e.type === "player" && e.id === myId
              );

              if (reward === "vaccineAndUpgrade") {
                // ★ 백신 + 업그레이드 둘 다 로컬 상태에 반영
                if (me) {
                  me.hasVaccine = true;
                  me.enhancedVaccine = true;
                }

                addLog(
                  "금고를 열고 충분한 양의 백신을 찾아냈습니다!"
                );
                addLog(
                  "금고에서 지하실 출입증을 발견했습니다."
                );
                addLog(
                  "지하실에서 외골격 슈트를 발견했습니다! 이제부터 한 턴에 두 칸씩 이동이 가능합니다."
                );
              } else if (reward === "upgradeOnly") {
                // ★ 기존 백신에 업그레이드만 반영
                if (me) {
                  if (!me.hasVaccine) {
                    me.hasVaccine = true;  // 안전장치: 서버 기준으론 이미 보유 중일 것
                  }
                  me.enhancedVaccine = true;
                }

                addLog(
                  "금고에서 지하실 출입증을 발견했습니다."
                );
                addLog(
                  "지하실에서 외골격 슈트를 발견했습니다! 이제부터 한 턴에 두 칸씩 이동이 가능합니다."
                );
              } else if (reward === "alreadyMax") {
                // 이미 강화 상태라면 별도 변경 없음
                addLog(
                  "이전 연구소와 같은 자료와 백신을 발견했습니다. 굳이 더 많이 들고갈 필요는 없어보이네요."
                );
              }
            }
            return;
          }
          // ── 교사 클라이언트: 해당 연구소 퀴즈에 대한 결과가 올라왔는지 확인 ──
          const result = data.result;
          if (!result) return;

          const answeredAt = result.answeredAt || 0;
          if (answeredAt <= (GameState.lastLabQuizResultAt || 0)) {
            return;
          }
          GameState.lastLabQuizResultAt = answeredAt;

          // 현재 대기 중인 연구소 퀴즈에 대한 결과인지 확인
          if (
            !GameState.labQuizPendingPlayerId ||
            GameState.labQuizPendingPlayerId !== data.targetPlayerId
          ) {
            return;
          }

          // 2번째 게임 단계 정보(stage)를 교사 쪽에도 반영
          if (typeof data.stage === "number") {
            GameState.labQuizPendingVaccinationStage = data.stage;
          }

          // 실제 효과 적용 (1편: 개발률, 2편: 백신 획득/업그레이드)
          const rewardType = applyLabQuizResult(!!result.correct);

          // 1편일 때는 개발률/백신완성 상태를 서버 stateRef에 반영
          if (NetState.stateRef && GameState.gameMode === GameModes.DEVELOPMENT) {
            NetState.stateRef.update({
              openedChests: GameState.openedChestCount,
              vaccineReady: GameState.vaccineActive
            });
          }

          // ▶ 학생에게도 "최종 결과"를 알려주기 위해
          //    result 노드에 서버 결정 결과를 덧붙인다.
          if (NetState.labQuizRef) {
            NetState.labQuizRef.child("result").update({
              reward: rewardType,              // 위에서 계산한 보상 타입
              mode: GameState.gameMode,        // DEVELOPMENT or VACCINATION
              stage: data.stage || 0,          // 2, 3 등
              playerId: data.targetPlayerId,   // 누구 결과인지
              processedAt: Date.now()          // 서버 결정 타임스탬프
            });
          }

          // ※ labQuizRef를 바로 set(null)로 비우지 않고,
          //    다음 퀴즈에서 set({quizId, ...})로 덮어쓰는 방식 사용
        });
      }
      
      // 학생/교사 공통 퀴즈 답안 처리
      function handleQuizAnswer(isCorrect) {
        // 이미 한 번 처리한 퀴즈라면 무시
        if (GameState.hasAnsweredQuiz) {
          return;
        }
        GameState.hasAnsweredQuiz = true;

        const context = GameState.quizContext; // "scan" | "lab" | null
        const quizId  = GameState.activeQuizId;

        // ★ 정답을 맞힌 모든 퀴즈는 ID를 기록해서, 이후 다시 풀지 않도록 함
        if (isCorrect && quizId) {
          GameState.quizSolvedCorrectly.add(quizId);
        }

        // 퀴즈창 닫기
        closeQuizOverlay();

        // ==============================
        // 1) 스캔(레이더) 퀴즈인 경우
        // ==============================
        if (context === "scan") {
          if (isCorrect) {
            addLog("정답입니다! 잠시 동안 시야 밖 연구소 위치가 강조 표시됩니다.");
            applyScanHighlightForCurrentPlayer();
          } else {
            addLog("아쉽지만 오답입니다. 개념을 다시 한 번 정리해 보세요.");
          }

          GameState.quizContext = null;
          GameState.activeQuizId = null;
          return;
        }

        // ==============================
        // 2) 연구소(Lab) 퀴즈인 경우
        // ==============================
        if (context === "lab") {
          // ★ 멀티플레이 '학생' 클라이언트일 때만
          //    - 여기서 찍는 로그는 그 학생 화면에만 보임
          if (NetState.roomId && !NetState.isTeacher && NetState.labQuizRef) {
            // ▶ 게임 모드(1편/2편) + 단계(2번째/3번째 연구소)에 따라
            //    학생 화면 로그를 분리해서 출력
            if (GameState.gameMode === GameModes.DEVELOPMENT) {
              // 1편: 백신 개발 모드
              if (isCorrect) {
                addLog(
                  "바이러스의 비밀 한가지를 밝혀냈습니다! 백신 개발률이 상승합니다."
                );
              } else {
                addLog(
                  "연구에 실패했습니다. 다시 시도할 필요가 있겠어요."
                );
              }
            } else if (GameState.gameMode === GameModes.VACCINATION) {
              // 2편: 백신 접종 모드
              const stage = GameState.labQuizPendingVaccinationStage || 0;

              if (stage === 2) {
                // 두 번째 연구소
                if (isCorrect) {
                  addLog(
                    "과학자의 금고를 열었습니다! 이 안에 백신이 들어있다면 좋을텐데요..."
                  );
                } else {
                  addLog(
                    "암호가 틀린탓일까요? 금고가 열리지 않고 더 강한 보안으로 잠겼습니다. 다시 열 수 있는 방법은 없는듯 보입니다..."
                  );
                }
              } else if (stage === 3) {
                // 세 번째 연구소
                if (isCorrect) {
                  addLog(
                    "정답입니다! 세 번째 연구소의 기록을 해석해, 강력한 백신에 대한 모든 정보를 얻었습니다! 이제 백신을 접종할 수 있겠네요 :)"
                  );
                } else {
                  addLog(
                    "아쉽지만 오답입니다. 세 번째 연구소의 복잡한 기록을 해석하지 못해, 최종 백신 시스템은 아직 완성되지 않았습니다."
                  );
                }
              } else {
                // 예외적으로 stage를 모를 때
                if (isCorrect) {
                  addLog(
                    "정답입니다! 연구소 기록을 해석해 백신과 관련된 중요한 단서를 얻었습니다."
                  );
                } else {
                  addLog(
                    "아쉽지만 오답입니다. 이번 연구소에서는 새로운 단서를 얻지 못했습니다."
                  );
                }
              }
            } else {
              // 혹시 모드 정보가 없을 때의 안전 로그
              if (isCorrect) {
                addLog(
                  "정답입니다! 연구소 문제를 해결해 중요한 정보를 얻었습니다."
                );
              } else {
                addLog(
                  "아쉽지만 오답입니다. 다시 한 번 생각해 보세요."
                );
              }
            }

            NetState.labQuizRef.child("result").set({
              correct: isCorrect,
              answeredBy: NetState.playerId || null,
              answeredAt: Date.now()
            });
            // 실제 개발률/백신 효과는 교사 쪽 subscribeLabQuiz()가 처리
          } else {
            // 싱글플레이 또는 교사 혼자 → 즉시 로컬 적용
            applyLabQuizResult(isCorrect);
          }

          GameState.quizContext = null;
          GameState.activeQuizId = null;
          return;
        }

        // 혹시 context가 없을 때 안전 처리
        GameState.quizContext = null;
        GameState.activeQuizId = null;
      }
      
      // 퀴즈 UI 초기화 (닫기 버튼 이벤트 연결)
      function initQuizUI() {
        if (UI.quizCloseBtn) {
          UI.quizCloseBtn.addEventListener("click", () => {
            closeQuizOverlay();
          });
        }
      }

      // ★★★ 스캔/퀴즈 시스템 추가 끝 ★★★


      // =========================
      // 10. 새 게임 / 턴 진행 (멀티플레이 대응)
      // =========================
      function resetLocalGame() {
        const state = GameState;
        state.currentTurn = 0;
        state.historyCumulativeInfected = [];
        state.historyNewInfected = [];
        state.lastRecordedTurn = 0;
        state.cumulativeInfectedTotal = 0;
        state.lastNewInfected = 0;
        state.lastReproductionIndex = 0;

        state.activeChestTiles = new Set();
        state.openedChestCount = 0;
        state.vaccineActive = false;
        state.playersMovedThisTurn = new Set();

        clearSelection();
        UI.logList.innerHTML = "";

        initEntities();
        initLabs();
        renderAll();
        addInitialLog();
        updateNewInfectedHistory();
      }

      async function resetGame() {
        // 학생은 새 게임 시작 불가
        if (NetState.roomId && !NetState.isTeacher) {
          alert("이 방에서는 교사만 새 게임을 시작할 수 있습니다.");
          return;
        }

        // 1) 내 화면 먼저 리셋
        resetLocalGame();

        // 2) 멀티플레이 방이면 DB에도 초기 상태 반영하여 학생 화면 갱신
        if (NetState.roomId && NetState.isTeacher && NetState.stateRef && NetState.playersRef) {
          const inf = computeInfectedCount();
          const tileStats = computeTileStats();

          // state 전체 초기화
          await NetState.stateRef.set({
            turn: GameState.currentTurn,
            vaccineReady: GameState.vaccineActive,
            openedChests: GameState.openedChestCount,
            infectedTotal: inf,
            cumulativeHistory: GameState.historyCumulativeInfected,
            newHistory: GameState.historyNewInfected,
            tiles: tileStats,
            gameMode: GameState.gameMode
          });

          // 기존 playersRef의 name/role 유지하면서 위치/상태 초기화
          const playersSnap = await NetState.playersRef.get();
          const remotePlayers = playersSnap.val() || {};
          const playerEntities = GameState.entities.filter(e => e.type === "player");

          for (const p of playerEntities) {
            const baseData = remotePlayers[p.id] || {
              name: p.id,
              role: "ai"
            };

            await NetState.playersRef.child(p.id).set({
              ...baseData,
              tileIndex: p.tileIndex,
              infected: p.infected,
              vaccinated: p.vaccinated || false
            });
          }

          // 학생이 이전 턴에 제출한 이동 기록 초기화
          if (NetState.movesRef) {
            await NetState.movesRef.set(null);
          }
        }
      }

      function toggleGameMode() {
        const state = GameState;

        if (state.gameMode === GameModes.DEVELOPMENT) {
          state.gameMode = GameModes.VACCINATION;

          for (const e of state.entities) {
            if (e.type !== "player") continue;
            e.visitedLabs = new Set();
            e.hasVaccine = false;
            e.enhancedVaccine = false;
          }

          addLog("=== 상당히 오랜 시간이 지났습니다. ===");
          addLog("과거 수많은 사람들을 죽음으로 몰고간 그 병이 다시 나타나기 시작했습니다.");
          addLog("소문에 의하면 지난 시대의 과학자들이 백신을 만들었지만");
          addLog("너무 늦어버린 탓에 사용도 못하고 죽음을 맞이했다네요.");
          addLog("연구소에서 백신을 얻을 수 있을지도 모르겠어요.");

          // ★ 교사라면 DB에도 gameMode 갱신
          if (NetState.roomId && NetState.isTeacher && NetState.stateRef) {
            NetState.stateRef.update({ gameMode: state.gameMode });
          }

          renderAll();
          return;
        }

        if (state.gameMode === GameModes.VACCINATION) {
          state.gameMode = GameModes.DEVELOPMENT;

          addLog("=== 시간축이 거꾸로 흐르며, 다시 첫 번째 게임으로 돌아갑니다. ===");
          addLog("도시는 아직 백신이 완성되지 않은 초기 감염 확산 단계입니다.");
          addLog("연구소를 찾아다니며 백신 개발률을 높여야 합니다.");
          addLog("이번에는 더 빠르게, 더 효율적으로 연구를 진행해 보세요.");

          // ★ 교사라면 DB에도 gameMode 갱신
          if (NetState.roomId && NetState.isTeacher && NetState.stateRef) {
            NetState.stateRef.update({ gameMode: state.gameMode });
          }

          renderAll();
          return;
        }
      }

      async function nextTurn() {
        const state = GameState;

        // 학생은 직접 턴 진행 불가
        if (NetState.roomId && !NetState.isTeacher) {
          alert("이 방에서는 교사만 턴을 진행할 수 있습니다.");
          return;
        }

        // 턴 증가 (회복 처리 등에서 사용)
        state.currentTurn++;

        // 조종되는 말은 자동 이동에서 제외되도록, 턴 시작 시점에 바로 기록
        state.playersMovedThisTurn = new Set(
          state.entities
          .filter(e => e.type === "player" && e.isHuman)
          .map(e => e.id)
        );

        // 멀티플레이(교사)일 때: 학생들이 제출한 이동 먼저 적용
        if (NetState.roomId && NetState.isTeacher && NetState.movesRef) {
          const movesSnap = await NetState.movesRef.get();
          const moves = movesSnap.val() || {};

          const players = state.entities.filter(e => e.type === "player");
          for (const p of players) {
            const m = moves[p.id];
            if (!m) continue;

            // onTileClick에서 { region: tileIndex }로 저장하므로 여기도 region 사용
            const dest = m.region;
            if (typeof dest !== "number") continue;

            const currentIndex = p.tileIndex;

            // 이동 가능한 최대 칸 수 판단
            let maxStep = 1;
            if (
              state.gameMode === GameModes.VACCINATION &&
              p.enhancedVaccine
            ) {
              maxStep = 2;
            }

            // 도달 가능한 타일 집합 계산
            const reachable = new Set();
            const n1 = getNeighborIndices(currentIndex);
            n1.forEach(n => reachable.add(n));

            if (maxStep >= 2) {
              n1.forEach(n => {
                getNeighborIndices(n).forEach(nn => {
                  if (nn !== currentIndex) reachable.add(nn);
                });
              });
            }

            // 실제로 도달 가능한 타일만 적용
            if (reachable.has(dest)) {
              p.tileIndex = dest;
              addLog(`(적용) ${p.id} : #${currentIndex} → #${dest}`);
              // 이 턴에 이미 이동한 플레이어로 표시 → 자동 이동에서 제외
              state.playersMovedThisTurn.add(p.id);
            }
          }

          // 이번 턴 이동 의사는 모두 처리했으니 비워 줌
          await NetState.movesRef.set(null);
        }

        // 시민 이동 + 자동 이동(AI 플레이어만)
        stepMovement();
        stepPlayerAutoMovement();   // 여기서 isHuman / playersMovedThisTurn를 보고 사람 말은 건드리지 않음
        applyLabEffects();

        // 2편(접종 모드)일 경우 접종 처리
        if (state.gameMode === GameModes.VACCINATION) {
          stepVaccination();
        }

        // 감염·회복 처리
        const newInf = stepInfection();
        state.cumulativeInfectedTotal += newInf;

        state.historyNewInfected.push({
          turn: state.currentTurn,
          newInfected: newInf
        });
        updateNewInfectedHistory();

        stepRecovery();
        renderAll();
        updateSelectedPlayerInfo();
        addLog(`새 감염자 ${newInf}명`);

        // 이 턴에서의 "이미 이동한 플레이어" 정보는 이제 필요 없으니 다음 턴용으로 초기화
        state.playersMovedThisTurn = new Set();

        // 멀티플레이 동기화(교사 → RTDB)
        if (NetState.roomId && NetState.isTeacher && NetState.stateRef && NetState.playersRef) {
          const inf = computeInfectedCount();
          const tileStats = computeTileStats();

          await NetState.stateRef.set({
            turn: state.currentTurn,
            vaccineReady: state.vaccineActive,
            openedChests: state.openedChestCount,
            infectedTotal: inf,
            cumulativeHistory: state.historyCumulativeInfected,
            newHistory: state.historyNewInfected,
            tiles: tileStats,
            gameMode: state.gameMode
          });

          const players = state.entities.filter(e => e.type === "player");
          const playerUpdates = {};

          for (const p of players) {
            playerUpdates[p.id] = {
              tileIndex: p.tileIndex,
              infected: p.infected
            };
          }

          await NetState.playersRef.update(playerUpdates);
        }
      }

      // =========================
      // 11. 초기화 & 이벤트 연결
      // =========================
      function makeRandomRoomId() {
        // 1000 ~ 9999 사이의 4자리 숫자 코드
        const n = Math.floor(Math.random() * 9000) + 1000;
        return String(n);
      }
      
      async function createRoomAsTeacher(nickname) {
        const roomId = makeRandomRoomId();
        const roomRef = rtdb.ref("rooms/" + roomId);

        const inf = computeInfectedCount();
        const tileStats = computeTileStats();

        await roomRef.set({
          createdAt: Date.now(),
          state: {
            turn: GameState.currentTurn,
            vaccineReady: GameState.vaccineActive,
            openedChests: GameState.openedChestCount || 0,
            infectedTotal: inf,
            cumulativeHistory: GameState.historyCumulativeInfected,
            newHistory: GameState.historyNewInfected,
            tiles: tileStats,
            gameMode: GameState.gameMode  
          }
        });

        NetState.roomId = roomId;
        NetState.isTeacher = true;
        NetState.nickname = nickname;
        NetState.roomRef = roomRef;
        NetState.playersRef = roomRef.child("players");
        NetState.movesRef = roomRef.child("moves");
        NetState.stateRef = roomRef.child("state");
        NetState.scanRef = roomRef.child("scan");  
        NetState.labQuizRef = roomRef.child("labQuiz");

        const players = GameState.entities.filter(e => e.type === "player");
        for (const p of players) {
          await NetState.playersRef.child(p.id).set({
            name: p.id,
            role: "ai",
            tileIndex: p.tileIndex,
            infected: p.infected
          });
        }

        subscribeRoomState();
        subscribePlayers();
        subscribeScan();  
        subscribeLabQuiz();

        addLog(`이 수업의 방 ID는 ${roomId}입니다. (학생에게 이 코드를 알려주세요)`);
        alert(`방이 생성되었습니다!\n방 ID: ${roomId}\n이 코드를 학생들에게 알려주세요.`);
      }

      async function joinRoomAsStudent(nickname, roomId) {
        const roomRef = rtdb.ref("rooms/" + roomId);
        const snap = await roomRef.get();

        if (!snap.exists()) {
          alert("해당 방 ID가 존재하지 않습니다.");
          return;
        }

        NetState.roomId = roomId;
        NetState.isTeacher = false;
        NetState.nickname = nickname;
        NetState.roomRef = roomRef;
        NetState.playersRef = roomRef.child("players");
        NetState.movesRef = roomRef.child("moves");
        NetState.stateRef = roomRef.child("state");
        NetState.scanRef = roomRef.child("scan");   // ★ 스캔용 경로
        NetState.labQuizRef = roomRef.child("labQuiz"); // ★ 연구소 퀴즈용 경로

        const playersSnap = await NetState.playersRef.get();
        const playersObj = playersSnap.val() || {};

        let chosenId = null;
        let remotePlayerInfo = null;
        for (const [id, info] of Object.entries(playersObj)) {
          if (!info.role || info.role === "ai") {
            chosenId = id;
            remotePlayerInfo = info;
            break;
          }
        }

        if (!chosenId) {
          alert("더 이상 할당 가능한 플레이어 말이 없습니다. (최대 인원 초과)");
          return;
        }

        const localPlayer = GameState.entities.find(
          e => e.type === "player" && e.id === chosenId
        );
        if (!localPlayer) {
          alert("로컬 플레이어 데이터를 찾을 수 없습니다.");
          return;
        }

        localPlayer._reserved = true;
        localPlayer.isHuman = true;
        localPlayer.tileIndex  = remotePlayerInfo.tileIndex ?? localPlayer.tileIndex;
        localPlayer.infected   = !!remotePlayerInfo.infected;
        localPlayer.vaccinated = !!remotePlayerInfo.vaccinated;

        NetState.playerId = chosenId;

        await NetState.playersRef.child(chosenId).update({
          name: nickname,
          role: "student"
        });

        subscribeRoomState();
        subscribePlayers();
        subscribeScan();
        subscribeLabQuiz();

        alert(`방에 입장했습니다! (ID: ${roomId})`);
      }

      function subscribeRoomState() {
        if (!NetState.stateRef) return;

        NetState.stateRef.on("value", snapshot => {
          const s = snapshot.val();
          if (!s) return;

          if (NetState.isTeacher) return;

          const prevMode = GameState.gameMode;

          GameState.currentTurn      = s.turn ?? GameState.currentTurn;
          GameState.openedChestCount = s.openedChests ?? GameState.openedChestCount;
          GameState.vaccineActive    = !!s.vaccineReady;

          GameState.remoteInfectedTotal = s.infectedTotal ?? null;

          if (Array.isArray(s.cumulativeHistory)) {
            GameState.historyCumulativeInfected = s.cumulativeHistory;
          }
          if (Array.isArray(s.newHistory)) {
            GameState.historyNewInfected = s.newHistory;
          }

          if (Array.isArray(s.tiles)) {
            GameState.remoteTileStats = s.tiles;

            const chestSet = new Set();
            s.tiles.forEach((t, idx) => {
              if (t && t.hasChest) chestSet.add(idx);
            });
            GameState.activeChestTiles = chestSet;
          }

          if (typeof s.gameMode === "string") {
            GameState.gameMode = s.gameMode;
          }

          updateInfectedHistory();
          updateNewInfectedHistory();

          if (prevMode !== GameState.gameMode) {
            if (prevMode === GameModes.DEVELOPMENT && GameState.gameMode === GameModes.VACCINATION) {
              addLog("=== 상당히 오랜 시간이 지났습니다. ===");
              addLog("과거 수많은 사람들을 죽음으로 몰고간 그 병이 다시 나타나기 시작했습니다.");
              addLog("소문에 의하면 지난 시대의 과학자들이 백신을 만들었지만");
              addLog("너무 늦어버린 탓에 사용도 못하고 죽음을 맞이했다네요.");
              addLog("연구소에서 백신을 얻을 수 있을지도 모르겠어요.");
            } else if (prevMode === GameModes.VACCINATION && GameState.gameMode === GameModes.DEVELOPMENT) {
              addLog("=== 시간축이 거꾸로 흐르며, 다시 첫 번째 게임으로 돌아갑니다. ===");
              addLog("도시는 아직 백신이 완성되지 않은 초기 감염 확산 단계입니다.");
              addLog("연구소를 찾아다니며 백신 개발률을 높여야 합니다.");
              addLog("이번에는 더 빠르게, 더 효율적으로 연구를 진행해 보세요.");
            }
          }

          renderAll();
          updateSelectedPlayerInfo();
        });
      }

      function subscribePlayers() {
        if (!NetState.playersRef) return;

        NetState.playersRef.on("value", snapshot => {
          const playersObj = snapshot.val() || {};
          const allPlayers = GameState.entities.filter(e => e.type === "player");

          allPlayers.forEach(p => {
            const remote = playersObj[p.id];

            if (!remote) {
              p.isHuman = false;
              return;
            }

            if (!NetState.isTeacher) {
              p.tileIndex  = remote.tileIndex ?? p.tileIndex;
              p.infected   = !!remote.infected;
            }
    
            p.isHuman = remote.role === "student" || remote.role === "teacher";
          });

          renderAll();
          updateSelectedPlayerInfo();
        });
      }

      
      async function init() {

        await loadSVGMap();
        
        initEntities();
        initLabs();
        renderAll();
        addInitialLog();
        updateSelectedPlayerInfo();
        initQuizUI(); // ★ 퀴즈 UI 초기 세팅

        const isTeacher = confirm("교사(방장)로 접속하시나요? 확인=예, 취소=아니오");
        const nickname = prompt("닉네임을 입력하세요", isTeacher ? "교사" : "학생");

        if (isTeacher) {
          await createRoomAsTeacher(nickname || "교사");
        } else {
          const roomId = prompt("참여할 방 ID를 입력하세요 (교사가 알려준 코드)");
          if (roomId) {
            await joinRoomAsStudent(nickname || "학생", roomId.trim());
          } else {
            alert("방 ID가 없어 싱글플레이 모드로 진행합니다.");
          }
        }

        if (isTeacher) {
          UI.switchGameModeBtn.style.display = "inline-block";
          UI.scanBtn.style.display = "inline-block";  // ★ 스캔 버튼 교사에게만 노출
        } else {
          UI.switchGameModeBtn.style.display = "none";
          UI.scanBtn.style.display = "none";
        }

        UI.addDummyLogBtn.addEventListener("click", () =>
          addLog("테스트 로그")
        );
        UI.nextTurnBtn.addEventListener("click", nextTurn);
        UI.newGameBtn.addEventListener("click", resetGame);
        UI.switchGameModeBtn.addEventListener("click", toggleGameMode);

        // 스캔 버튼 클릭 시 퀴즈-레이더 발동 (교사 전용)
        UI.scanBtn.addEventListener("click", triggerScanForTeacher);

        UI.vaccineToggle.addEventListener("change", () => {
          GameState.vaccineFeatureEnabled = UI.vaccineToggle.checked;
          if (!GameState.vaccineFeatureEnabled) {
            addLog(
              "백신/연구소 시스템이 비활성화되었습니다."
            );
          } else {
            addLog(
              "백신/연구소 시스템이 활성화되었습니다. 연구소를 찾아 백신 개발을 진행하세요."
            );
          }
          renderAll();
        });
      }

      init();
    </script>
  </body>
  </html>





















